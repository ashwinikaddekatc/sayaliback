/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Undocumented experimental feature: inline editing.
 *
 * TODO: support more types of inputs: checkbox, radio, ...
 * TODO: Mirror input attributes from the host to the actual input: size, min, max, placeholder, ...
 */
import { Component } from '@angular/core';
import { StackControl } from './stack-control';
import { ClrStackView } from './stack-view';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './stack-view';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/forms';

function ClrStackInput_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.model);
} }
function ClrStackInput_input_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 2);
    ɵngcc0.ɵɵlistener("ngModelChange", function ClrStackInput_input_1_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.model = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", ctx_r1.type)("ngModel", ctx_r1.model);
} }
export class ClrStackInput extends StackControl {
    constructor(stackView) {
        super(stackView);
        this.stackView = stackView;
        this.type = 'text';
    }
}
ClrStackInput.ɵfac = function ClrStackInput_Factory(t) { return new (t || ClrStackInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ClrStackView)); };
ClrStackInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrStackInput, selectors: [["clr-stack-input"]], inputs: { model: ["clrModel", "model"], type: "type" }, outputs: { modelChange: "clrModelChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "type", "ngModel", "ngModelChange", 4, "ngIf"], [3, "type", "ngModel", "ngModelChange"]], template: function ClrStackInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ClrStackInput_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ClrStackInput_input_1_Template, 1, 2, "input", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.stackView.editing);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stackView.editing);
    } }, directives: [ɵngcc2.NgIf, ɵngcc3.DefaultValueAccessor, ɵngcc3.NgControlStatus, ɵngcc3.NgModel], encapsulation: 2 });
ClrStackInput.ctorParameters = () => [
    { type: ClrStackView }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClrStackInput, [{
        type: Component,
        args: [{
                selector: 'clr-stack-input',
                inputs: ['model: clrModel', 'type'],
                outputs: ['modelChange: clrModelChange'],
                template: `
    <span *ngIf="!stackView.editing">{{ model }}</span>
    <input [type]="type" *ngIf="stackView.editing" [(ngModel)]="model" />
  `
            }]
    }], function () { return [{ type: ɵngcc1.ClrStackView }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2staW5wdXQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2Nsci1hbmd1bGFyL3NyYy9kYXRhL3N0YWNrLXZpZXcvc3RhY2staW5wdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFFSCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXNUMsTUFBTSxPQUFPLGFBQWMsU0FBUSxZQUFZO0FBQy9DLElBRUUsWUFBbUIsU0FBdUI7QUFDNUMsUUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckIsUUFGcUIsY0FBUyxHQUFULFNBQVMsQ0FBYztBQUFDLFFBRjNDLFNBQUksR0FBRyxNQUFNLENBQUM7QUFDaEIsSUFHRSxDQUFDO0FBQ0g7eUNBZkMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxpQkFBaUIsa0JBQzNCLE1BQU0sRUFBRSxDQUFDO1FBQWlCLEVBQUUsTUFBTSxDQUFDLGtCQUNuQyxPQUFPLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxrQkFDeEMsUUFBUSxFQUFFLHVJQUdULGNBQ0Y7Ozs7Ozs7NkhBQ0k7QUFBQztBQUF1QyxZQVhwQyxZQUFZO0FBQUc7Ozs7Ozs7Ozs7Ozs2RUFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuLyoqXG4gKiBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLlxuICpcbiAqIFRPRE86IHN1cHBvcnQgbW9yZSB0eXBlcyBvZiBpbnB1dHM6IGNoZWNrYm94LCByYWRpbywgLi4uXG4gKiBUT0RPOiBNaXJyb3IgaW5wdXQgYXR0cmlidXRlcyBmcm9tIHRoZSBob3N0IHRvIHRoZSBhY3R1YWwgaW5wdXQ6IHNpemUsIG1pbiwgbWF4LCBwbGFjZWhvbGRlciwgLi4uXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdGFja0NvbnRyb2wgfSBmcm9tICcuL3N0YWNrLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLWlucHV0JyxcbiAgaW5wdXRzOiBbJ21vZGVsOiBjbHJNb2RlbCcsICd0eXBlJ10sXG4gIG91dHB1dHM6IFsnbW9kZWxDaGFuZ2U6IGNsck1vZGVsQ2hhbmdlJ10sXG4gIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gKm5nSWY9XCIhc3RhY2tWaWV3LmVkaXRpbmdcIj57eyBtb2RlbCB9fTwvc3Bhbj5cbiAgICA8aW5wdXQgW3R5cGVdPVwidHlwZVwiICpuZ0lmPVwic3RhY2tWaWV3LmVkaXRpbmdcIiBbKG5nTW9kZWwpXT1cIm1vZGVsXCIgLz5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tJbnB1dCBleHRlbmRzIFN0YWNrQ29udHJvbCB7XG4gIHR5cGUgPSAndGV4dCc7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7XG4gICAgc3VwZXIoc3RhY2tWaWV3KTtcbiAgfVxufVxuIl19