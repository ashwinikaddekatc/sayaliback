/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChild, ElementRef, Inject, Input, PLATFORM_ID } from '@angular/core';
import { ClrTimelineStepState } from './enums/timeline-step-state.enum';
import { TimelineIconAttributeService } from './providers/timeline-icon-attribute.service';
import { ClrTimelineStepTitle } from './timeline-step-title';
import { isPlatformBrowser } from '@angular/common';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './providers/timeline-icon-attribute.service';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '../icon/icon';
import * as ɵngcc4 from '../progress/spinner/spinner';

function ClrTimelineStep_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "cds-icon");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("status", ctx_r0.iconStatus)("shape", ctx_r0.iconShape)("aria-label", ctx_r0.iconAriaLabel)("aria-current", ctx_r0.iconAriaCurrent);
} }
function ClrTimelineStep_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "clr-spinner", 4);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.iconAriaLabel);
} }
const _c0 = [[["clr-timeline-step-header"]], [["clr-timeline-step-title"]], [["clr-timeline-step-description"]]];
const _c1 = ["clr-timeline-step-header", "clr-timeline-step-title", "clr-timeline-step-description"];
export class ClrTimelineStep {
    constructor(iconAttributeService, platformId) {
        this.iconAttributeService = iconAttributeService;
        this.platformId = platformId;
        this.state = ClrTimelineStepState.NOT_STARTED;
    }
    ngAfterContentInit() {
        if (this.stepTitle && isPlatformBrowser(this.platformId)) {
            this.stepTitleText = this.stepTitle.nativeElement.innerText;
        }
    }
    get iconAriaCurrent() {
        return this.state === ClrTimelineStepState.CURRENT;
    }
    get iconAriaLabel() {
        return this.iconAttributeService.getAriaLabel(this.state);
    }
    get iconShape() {
        return this.iconAttributeService.getIconShape(this.state);
    }
    get iconStatus() {
        return this.iconAttributeService.getIconStatus(this.state);
    }
    get isProcessing() {
        return this.state === ClrTimelineStepState.PROCESSING;
    }
}
ClrTimelineStep.ɵfac = function ClrTimelineStep_Factory(t) { return new (t || ClrTimelineStep)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.TimelineIconAttributeService), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
ClrTimelineStep.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrTimelineStep, selectors: [["clr-timeline-step"]], contentQueries: function ClrTimelineStep_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrTimelineStepTitle, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTitle = _t.first);
    } }, hostVars: 2, hostBindings: function ClrTimelineStep_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-timeline-step", true);
    } }, inputs: { state: ["clrState", "state"] }, ngContentSelectors: _c1, decls: 9, vars: 3, consts: [[1, "clr-sr-only"], [4, "ngIf", "ngIfElse"], [1, "clr-timeline-step-body"], ["processing", ""], ["clrMedium", ""]], template: function ClrTimelineStep_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "span", 0);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ClrTimelineStep_ng_container_3_Template, 2, 4, "ng-container", 1);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵprojection(6, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ClrTimelineStep_ng_template_7_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(8);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.stepTitleText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isProcessing)("ngIfElse", _r1);
    } }, directives: [ɵngcc2.NgIf, ɵngcc3.CdsIconCustomTag, ɵngcc4.ClrSpinner], encapsulation: 2 });
ClrTimelineStep.ctorParameters = () => [
    { type: TimelineIconAttributeService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
ClrTimelineStep.propDecorators = {
    state: [{ type: Input, args: ['clrState',] }],
    stepTitle: [{ type: ContentChild, args: [ClrTimelineStepTitle, { read: ElementRef },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClrTimelineStep, [{
        type: Component,
        args: [{
                selector: 'clr-timeline-step',
                template: `
    <ng-content select="clr-timeline-step-header"></ng-content>
    <span class="clr-sr-only">{{ stepTitleText }}</span>
    <ng-container *ngIf="!isProcessing; else processing">
      <cds-icon
        [attr.status]="iconStatus"
        [attr.shape]="iconShape"
        [attr.aria-label]="iconAriaLabel"
        [attr.aria-current]="iconAriaCurrent"
      >
      </cds-icon>
    </ng-container>
    <div class="clr-timeline-step-body">
      <ng-content select="clr-timeline-step-title"></ng-content>
      <ng-content select="clr-timeline-step-description"></ng-content>
    </div>

    <ng-template #processing>
      <clr-spinner clrMedium [attr.aria-label]="iconAriaLabel"></clr-spinner>
    </ng-template>
  `,
                host: { '[class.clr-timeline-step]': 'true' }
            }]
    }], function () { return [{ type: ɵngcc1.TimelineIconAttributeService }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { state: [{
            type: Input,
            args: ['clrState']
        }], stepTitle: [{
            type: ContentChild,
            args: [ClrTimelineStepTitle, { read: ElementRef }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZWxpbmUtc3RlcC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2xyLWFuZ3VsYXIvc3JjL3RpbWVsaW5lL3RpbWVsaW5lLXN0ZXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWhHLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzNGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzdELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQnBELE1BQU0sT0FBTyxlQUFlO0FBQzVCLElBTUUsWUFDVSxvQkFBa0QsRUFDN0IsVUFBZTtBQUM3QyxRQUZTLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBOEI7QUFBQyxRQUM5QixlQUFVLEdBQVYsVUFBVSxDQUFLO0FBQ2hELFFBVHFCLFVBQUssR0FBeUIsb0JBQW9CLENBQUMsV0FBVyxDQUFDO0FBQ3BGLElBUUssQ0FBQztBQUNOLElBQ0Usa0JBQWtCO0FBQ3BCLFFBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtBQUM5RCxZQUFNLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDO0FBQ2xFLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFLElBQUksZUFBZTtBQUFLLFFBQ3RCLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxPQUFPLENBQUM7QUFDdkQsSUFBRSxDQUFDO0FBQ0gsSUFDRSxJQUFJLGFBQWE7QUFBSyxRQUNwQixPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlELElBQUUsQ0FBQztBQUNILElBQ0UsSUFBSSxTQUFTO0FBQUssUUFDaEIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM5RCxJQUFFLENBQUM7QUFDSCxJQUNFLElBQUksVUFBVTtBQUFLLFFBQ2pCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0QsSUFBRSxDQUFDO0FBQ0gsSUFDRSxJQUFJLFlBQVk7QUFBSyxRQUNuQixPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssb0JBQW9CLENBQUMsVUFBVSxDQUFDO0FBQzFELElBQUUsQ0FBQztBQUNIOzJDQTlEQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLG1CQUFtQixrQkFDN0IsUUFBUSxFQUFFOzs7Ozs7OztpR0FvQlQsa0JBQ0QsSUFBSSxFQUFFLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxFQUFFLGNBQzlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0dBQ0k7QUFBQztBQUNVLFlBOUJQLDRCQUE0QjtBQUFJLDRDQXNDcEMsTUFBTSxTQUFDLFdBQVc7QUFBUTtBQUFHO0FBR3RCLG9CQVhULEtBQUssU0FBQyxVQUFVO0FBQU8sd0JBR3ZCLFlBQVksU0FBQyxvQkFBb0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7QUFDdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5wdXQsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsclRpbWVsaW5lU3RlcFN0YXRlIH0gZnJvbSAnLi9lbnVtcy90aW1lbGluZS1zdGVwLXN0YXRlLmVudW0nO1xuaW1wb3J0IHsgVGltZWxpbmVJY29uQXR0cmlidXRlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RpbWVsaW5lLWljb24tYXR0cmlidXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyVGltZWxpbmVTdGVwVGl0bGUgfSBmcm9tICcuL3RpbWVsaW5lLXN0ZXAtdGl0bGUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGltZWxpbmUtc3RlcCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXRpbWVsaW5lLXN0ZXAtaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDxzcGFuIGNsYXNzPVwiY2xyLXNyLW9ubHlcIj57eyBzdGVwVGl0bGVUZXh0IH19PC9zcGFuPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNQcm9jZXNzaW5nOyBlbHNlIHByb2Nlc3NpbmdcIj5cbiAgICAgIDxjZHMtaWNvblxuICAgICAgICBbYXR0ci5zdGF0dXNdPVwiaWNvblN0YXR1c1wiXG4gICAgICAgIFthdHRyLnNoYXBlXT1cImljb25TaGFwZVwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaWNvbkFyaWFMYWJlbFwiXG4gICAgICAgIFthdHRyLmFyaWEtY3VycmVudF09XCJpY29uQXJpYUN1cnJlbnRcIlxuICAgICAgPlxuICAgICAgPC9jZHMtaWNvbj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLXRpbWVsaW5lLXN0ZXAtYm9keVwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXRpbWVsaW5lLXN0ZXAtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItdGltZWxpbmUtc3RlcC1kZXNjcmlwdGlvblwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cblxuICAgIDxuZy10ZW1wbGF0ZSAjcHJvY2Vzc2luZz5cbiAgICAgIDxjbHItc3Bpbm5lciBjbHJNZWRpdW0gW2F0dHIuYXJpYS1sYWJlbF09XCJpY29uQXJpYUxhYmVsXCI+PC9jbHItc3Bpbm5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLXRpbWVsaW5lLXN0ZXBdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRpbWVsaW5lU3RlcCB7XG4gIEBJbnB1dCgnY2xyU3RhdGUnKSBzdGF0ZTogQ2xyVGltZWxpbmVTdGVwU3RhdGUgPSBDbHJUaW1lbGluZVN0ZXBTdGF0ZS5OT1RfU1RBUlRFRDtcblxuICBwdWJsaWMgc3RlcFRpdGxlVGV4dDogc3RyaW5nO1xuICBAQ29udGVudENoaWxkKENsclRpbWVsaW5lU3RlcFRpdGxlLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgc3RlcFRpdGxlOiBFbGVtZW50UmVmO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWNvbkF0dHJpYnV0ZVNlcnZpY2U6IFRpbWVsaW5lSWNvbkF0dHJpYnV0ZVNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBhbnlcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAodGhpcy5zdGVwVGl0bGUgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5zdGVwVGl0bGVUZXh0ID0gdGhpcy5zdGVwVGl0bGUubmF0aXZlRWxlbWVudC5pbm5lclRleHQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGljb25BcmlhQ3VycmVudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ2xyVGltZWxpbmVTdGVwU3RhdGUuQ1VSUkVOVDtcbiAgfVxuXG4gIGdldCBpY29uQXJpYUxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkF0dHJpYnV0ZVNlcnZpY2UuZ2V0QXJpYUxhYmVsKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgZ2V0IGljb25TaGFwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmljb25BdHRyaWJ1dGVTZXJ2aWNlLmdldEljb25TaGFwZSh0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIGdldCBpY29uU3RhdHVzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkF0dHJpYnV0ZVNlcnZpY2UuZ2V0SWNvblN0YXR1cyh0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIGdldCBpc1Byb2Nlc3NpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENsclRpbWVsaW5lU3RlcFN0YXRlLlBST0NFU1NJTkc7XG4gIH1cbn1cbiJdfQ==