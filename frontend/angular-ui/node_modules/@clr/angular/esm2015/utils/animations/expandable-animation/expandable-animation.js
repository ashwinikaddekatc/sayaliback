/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ElementRef, HostBinding, HostListener, Input } from '@angular/core';
import { animate, style, transition, trigger } from '@angular/animations';
import { DomAdapter } from '../../dom-adapter/dom-adapter';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../dom-adapter/dom-adapter';

const _c0 = ["*"];
export class ClrExpandableAnimation {
    constructor(element, domAdapter) {
        this.element = element;
        this.domAdapter = domAdapter;
        this.startHeight = 0;
    }
    get expandAnimation() {
        return { value: this.clrExpandTrigger, params: { startHeight: this.startHeight } };
    }
    animationDone() {
        // A "safe" auto-update of the height ensuring basic OOTB user experience .
        // Prone to small jumps in initial animation height if data was changed in the meantime, window was resized, etc.
        // For optimal behavior call manually updateStartHeight() from the parent component before initiating the update.
        this.updateStartHeight();
    }
    updateStartHeight() {
        this.startHeight = this.domAdapter.computedHeight(this.element.nativeElement) || 0;
    }
}
ClrExpandableAnimation.ɵfac = function ClrExpandableAnimation_Factory(t) { return new (t || ClrExpandableAnimation)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomAdapter)); };
ClrExpandableAnimation.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrExpandableAnimation, selectors: [["clr-expandable-animation"]], hostVars: 1, hostBindings: function ClrExpandableAnimation_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵsyntheticHostListener("@expandAnimation.done", function ClrExpandableAnimation_animation_expandAnimation_done_HostBindingHandler() { return ctx.animationDone(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@expandAnimation", ctx.expandAnimation);
    } }, inputs: { clrExpandTrigger: "clrExpandTrigger" }, features: [ɵngcc0.ɵɵProvidersFeature([DomAdapter])], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ClrExpandableAnimation_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n        display: block;\n      }"], data: { animation: [
            trigger('expandAnimation', [
                transition('true <=> false', [
                    style({ height: '{{startHeight}}px', overflow: 'hidden' }),
                    animate('0.2s ease-in-out', style({ height: '*' })),
                ]),
            ]),
        ] } });
ClrExpandableAnimation.ctorParameters = () => [
    { type: ElementRef },
    { type: DomAdapter }
];
ClrExpandableAnimation.propDecorators = {
    clrExpandTrigger: [{ type: Input }],
    expandAnimation: [{ type: HostBinding, args: ['@expandAnimation',] }],
    animationDone: [{ type: HostListener, args: ['@expandAnimation.done',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClrExpandableAnimation, [{
        type: Component,
        args: [{
                selector: 'clr-expandable-animation',
                template: ` <ng-content></ng-content> `,
                animations: [
                    trigger('expandAnimation', [
                        transition('true <=> false', [
                            style({ height: '{{startHeight}}px', overflow: 'hidden' }),
                            animate('0.2s ease-in-out', style({ height: '*' })),
                        ]),
                    ]),
                ],
                providers: [DomAdapter],
                styles: [`
      :host {
        display: block;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.DomAdapter }]; }, { expandAnimation: [{
            type: HostBinding,
            args: ['@expandAnimation']
        }], animationDone: [{
            type: HostListener,
            args: ['@expandAnimation.done']
        }], clrExpandTrigger: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS1hbmltYXRpb24uanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2Nsci1hbmd1bGFyL3NyYy91dGlscy9hbmltYXRpb25zL2V4cGFuZGFibGUtYW5pbWF0aW9uL2V4cGFuZGFibGUtYW5pbWF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXhGLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMxRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7Ozs7O0FBc0IzRCxNQUFNLE9BQU8sc0JBQXNCO0FBQ25DLElBSUUsWUFBb0IsT0FBbUIsRUFBVSxVQUFzQjtBQUFJLFFBQXZELFlBQU8sR0FBUCxPQUFPLENBQVk7QUFBQyxRQUFTLGVBQVUsR0FBVixVQUFVLENBQVk7QUFBQyxRQUZ4RSxnQkFBVyxHQUFHLENBQUMsQ0FBQztBQUNsQixJQUM0RSxDQUFDO0FBQzdFLElBQ0UsSUFDSSxlQUFlO0FBQ3JCLFFBQUksT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO0FBQ3ZGLElBQUUsQ0FBQztBQUNILElBRUUsYUFBYTtBQUNmLFFBQUksMkVBQTJFO0FBQy9FLFFBQUksaUhBQWlIO0FBQ3JILFFBQUksaUhBQWlIO0FBQ3JILFFBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7QUFDN0IsSUFBRSxDQUFDO0FBQ0gsSUFDRSxpQkFBaUI7QUFDbkIsUUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZGLElBQUUsQ0FBQztBQUNIO2tEQTNDQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLDBCQUEwQixrQkFDcEMsUUFBUSxFQUFFLDZCQUE2QixrQkFRdkMsVUFBVSxFQUFFO3FCQUNWLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSwwQkFDekIsVUFBVSxDQUFDLGdCQUFnQixFQUFFLDhCQUMzQixLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDLDhCQUMxRDtDQUFPLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsMkJBQ3BELENBQUMsdUJBQ0gsQ0FBQyxtQkFDSCxrQkFDRCxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUM7RUFkckI7bUNBSUMsZUFXSjs7Ozs7Ozs7Ozs7ZUFDSTtBQUFDO0FBQ1UsWUExQkksVUFBVTtBQUFJLFlBR3pCLFVBQVU7QUFBRztBQUFHO0FBRW5CLCtCQXFCSCxLQUFLO0FBQUssOEJBTVYsV0FBVyxTQUFDLGtCQUFrQjtBQUM1Qiw0QkFJRixZQUFZLFNBQUMsdUJBQXVCO0FBQ25DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGFuaW1hdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZXhwYW5kYWJsZS1hbmltYXRpb24nLFxuICB0ZW1wbGF0ZTogYCA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG4gICAgYCxcbiAgXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2V4cGFuZEFuaW1hdGlvbicsIFtcbiAgICAgIHRyYW5zaXRpb24oJ3RydWUgPD0+IGZhbHNlJywgW1xuICAgICAgICBzdHlsZSh7IGhlaWdodDogJ3t7c3RhcnRIZWlnaHR9fXB4Jywgb3ZlcmZsb3c6ICdoaWRkZW4nIH0pLFxuICAgICAgICBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSksXG4gICAgICBdKSxcbiAgICBdKSxcbiAgXSxcbiAgcHJvdmlkZXJzOiBbRG9tQWRhcHRlcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsckV4cGFuZGFibGVBbmltYXRpb24ge1xuICBASW5wdXQoKSBjbHJFeHBhbmRUcmlnZ2VyOiBhbnk7XG5cbiAgc3RhcnRIZWlnaHQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyKSB7fVxuXG4gIEBIb3N0QmluZGluZygnQGV4cGFuZEFuaW1hdGlvbicpXG4gIGdldCBleHBhbmRBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuY2xyRXhwYW5kVHJpZ2dlciwgcGFyYW1zOiB7IHN0YXJ0SGVpZ2h0OiB0aGlzLnN0YXJ0SGVpZ2h0IH0gfTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ0BleHBhbmRBbmltYXRpb24uZG9uZScpXG4gIGFuaW1hdGlvbkRvbmUoKSB7XG4gICAgLy8gQSBcInNhZmVcIiBhdXRvLXVwZGF0ZSBvZiB0aGUgaGVpZ2h0IGVuc3VyaW5nIGJhc2ljIE9PVEIgdXNlciBleHBlcmllbmNlIC5cbiAgICAvLyBQcm9uZSB0byBzbWFsbCBqdW1wcyBpbiBpbml0aWFsIGFuaW1hdGlvbiBoZWlnaHQgaWYgZGF0YSB3YXMgY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWUsIHdpbmRvdyB3YXMgcmVzaXplZCwgZXRjLlxuICAgIC8vIEZvciBvcHRpbWFsIGJlaGF2aW9yIGNhbGwgbWFudWFsbHkgdXBkYXRlU3RhcnRIZWlnaHQoKSBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGJlZm9yZSBpbml0aWF0aW5nIHRoZSB1cGRhdGUuXG4gICAgdGhpcy51cGRhdGVTdGFydEhlaWdodCgpO1xuICB9XG5cbiAgdXBkYXRlU3RhcnRIZWlnaHQoKSB7XG4gICAgdGhpcy5zdGFydEhlaWdodCA9IHRoaXMuZG9tQWRhcHRlci5jb21wdXRlZEhlaWdodCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkgfHwgMDtcbiAgfVxufVxuIl19