/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 *
 */
import { Directive, Inject, Input, Renderer2, TemplateRef, ViewContainerRef, EventEmitter, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { ClrPopoverToggleService } from './providers/popover-toggle.service';
import { ClrPopoverEventsService } from './providers/popover-events.service';
import { ClrPopoverPositionService } from './providers/popover-position.service';
import { debounceTime } from 'rxjs/operators';
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/** @dynamic */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './providers/popover-position.service';
import * as ɵngcc2 from './providers/popover-events.service';
import * as ɵngcc3 from './providers/popover-toggle.service';
export class ClrPopoverContent {
    constructor(document, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
        this.document = document;
        this.container = container;
        this.template = template;
        this.renderer = renderer;
        this.smartPositionService = smartPositionService;
        this.smartEventsService = smartEventsService;
        this.smartOpenService = smartOpenService;
        this.subscriptions = [];
        this.shouldRealign = false;
        // Check-collector pattern:
        // In order to get accurate content height/width values, we cannot calculate alignment offsets until
        // after the projected content has stabilized.
        // As multiple check events may happen in the same rendering cycle, we need to collect all events
        // and only act after the content is really stable. Or we may get wrong intermediate positioning values.
        // We will channel subsequent content check events through this observable.
        this.checkCollector = new EventEmitter();
    }
    set open(value) {
        this.smartOpenService.open = !!value;
    }
    set contentAt(position) {
        this.smartPositionService.position = position;
    }
    set outsideClickClose(clickToClose) {
        this.smartEventsService.outsideClickClose = !!clickToClose;
    }
    set scrollToClose(scrollToClose) {
        this.smartEventsService.scrollToClose = !!scrollToClose;
    }
    ngAfterViewInit() {
        this.subscriptions.push(this.smartOpenService.openChange.subscribe(change => {
            if (change) {
                this.addContent();
            }
            else {
                this.removeContent();
            }
        }), this.smartPositionService.shouldRealign.subscribe(() => {
            this.shouldRealign = true;
            // Avoid flickering on initialization, caused by the asynchronous nature of the
            // check-collector pattern.
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
            }
        }), 
        // Here we collect subsequent synchronously received content-check events and only take action
        // at the end of the cycle. See below for details on the check-collector pattern.
        this.checkCollector.pipe(debounceTime(0)).subscribe(() => {
            this.alignContent();
            this.shouldRealign = false;
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '1');
            }
        }));
    }
    ngOnDestroy() {
        this.removeContent();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    removeContent() {
        if (!this.view) {
            return;
        }
        this.view.rootNodes.forEach(node => this.renderer.removeChild(this.document.body, node));
        this.container.clear();
        delete this.view;
    }
    /**
     * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
     * A note about the use of appendChild/removeChild
     * The DebugElement is keeping a reference to the detached node and its unclear why.
     * This does warrant further investigation. But, since it doesn't happen in production mode
     * it is a low priority issue for now.
     */
    addContent() {
        // Create the view container
        this.view = this.container.createEmbeddedView(this.template);
        this.smartEventsService.contentRef = this.view.rootNodes[0]; // So we know where/what to set close focus on
        this.renderer.addClass(this.view.rootNodes[0], 'clr-popover-content');
        // Reset to the begining of the document to be available for sizing/positioning calculations.
        // If we add new content to the bottom it triggers changes in the layout that may lead to false anchor
        // coordinates values.
        this.renderer.setStyle(this.view.rootNodes[0], 'top', '0px');
        this.renderer.setStyle(this.view.rootNodes[0], 'left', '0px');
        // We need to hide it during the calculation phase, while it's not yet finally positioned.
        this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
        this.renderer.listen(this.view.rootNodes[0], 'click', event => {
            this.smartOpenService.openEvent = event;
        });
        this.view.rootNodes.forEach(node => {
            this.renderer.appendChild(this.document.body, node);
        });
        // Mark for realingment on the next content-check cycle.
        this.shouldRealign = true;
    }
    ngAfterContentChecked() {
        if (this.smartOpenService.open && this.view && this.shouldRealign) {
            // Channel content-check event through the check-collector
            this.checkCollector.emit();
        }
    }
    alignContent() {
        if (!this.view) {
            return;
        }
        const positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
        this.renderer.setStyle(this.view.rootNodes[0], 'top', `${positionCoords.yOffset}px`);
        this.renderer.setStyle(this.view.rootNodes[0], 'left', `${positionCoords.xOffset}px`);
        this.smartOpenService.popoverAlignedEmit(this.view.rootNodes[0]);
    }
}
ClrPopoverContent.ɵfac = function ClrPopoverContent_Factory(t) { return new (t || ClrPopoverContent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ClrPopoverPositionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ClrPopoverEventsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ClrPopoverToggleService)); };
ClrPopoverContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClrPopoverContent, selectors: [["", "clrPopoverContent", ""]], inputs: { open: ["clrPopoverContent", "open"], contentAt: ["clrPopoverContentAt", "contentAt"], outsideClickClose: ["clrPopoverContentOutsideClickToClose", "outsideClickClose"], scrollToClose: ["clrPopoverContentScrollToClose", "scrollToClose"] } });
ClrPopoverContent.ctorParameters = () => [
    { type: HTMLDocument, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: Renderer2 },
    { type: ClrPopoverPositionService },
    { type: ClrPopoverEventsService },
    { type: ClrPopoverToggleService }
];
ClrPopoverContent.propDecorators = {
    open: [{ type: Input, args: ['clrPopoverContent',] }],
    contentAt: [{ type: Input, args: ['clrPopoverContentAt',] }],
    outsideClickClose: [{ type: Input, args: ['clrPopoverContentOutsideClickToClose',] }],
    scrollToClose: [{ type: Input, args: ['clrPopoverContentScrollToClose',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClrPopoverContent, [{
        type: Directive,
        args: [{ selector: '[clrPopoverContent]' }]
    }], function () { return [{ type: HTMLDocument, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.ClrPopoverPositionService }, { type: ɵngcc2.ClrPopoverEventsService }, { type: ɵngcc3.ClrPopoverToggleService }]; }, { open: [{
            type: Input,
            args: ['clrPopoverContent']
        }], contentAt: [{
            type: Input,
            args: ['clrPopoverContentAt']
        }], outsideClickClose: [{
            type: Input,
            args: ['clrPopoverContentOutsideClickToClose']
        }], scrollToClose: [{
            type: Input,
            args: ['clrPopoverContentScrollToClose']
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1jb250ZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jbHItYW5ndWxhci9zcmMvdXRpbHMvcG9wb3Zlci9wb3BvdmVyLWNvbnRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxPQUFPLEVBQ0wsU0FBUyxFQUVULE1BQU0sRUFDTixLQUFLLEVBRUwsU0FBUyxFQUNULFdBQVcsRUFDWCxnQkFBZ0IsRUFFaEIsWUFBWSxHQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUczQyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUM3RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUM3RSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUVqRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFOUMseUVBQXlFO0FBQ3pFLGVBQWU7Ozs7O0FBRWYsTUFBTSxPQUFPLGlCQUFpQjtBQUFHLElBd0IvQixZQUM0QixRQUFzQixFQUN4QyxTQUEyQixFQUMzQixRQUEwQixFQUMxQixRQUFtQixFQUNuQixvQkFBK0MsRUFDL0Msa0JBQTJDLEVBQzNDLGdCQUF5QztBQUNsRCxRQVAyQixhQUFRLEdBQVIsUUFBUSxDQUFjO0FBQUMsUUFDekMsY0FBUyxHQUFULFNBQVMsQ0FBa0I7QUFBQyxRQUM1QixhQUFRLEdBQVIsUUFBUSxDQUFrQjtBQUFDLFFBQzNCLGFBQVEsR0FBUixRQUFRLENBQVc7QUFBQyxRQUNwQix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQTJCO0FBQUMsUUFDaEQsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUF5QjtBQUFDLFFBQzVDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBeUI7QUFD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ICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjAgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUmVuZGVyZXIyLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgRXZlbnRFbWl0dGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BvcG92ZXItdG9nZ2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wb3BvdmVyLWV2ZW50cy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wb3BvdmVyLXBvc2l0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlclBvc2l0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BvcG92ZXItcG9zaXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjAzNTEjaXNzdWVjb21tZW50LTM0NDAwOTg4N1xuLyoqIEBkeW5hbWljICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUG9wb3ZlckNvbnRlbnRdJyB9KVxuZXhwb3J0IGNsYXNzIENsclBvcG92ZXJDb250ZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8dm9pZD47XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBASW5wdXQoJ2NsclBvcG92ZXJDb250ZW50JylcbiAgcHVibGljIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW4gPSAhIXZhbHVlO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudEF0JylcbiAgc2V0IGNvbnRlbnRBdChwb3NpdGlvbjogQ2xyUG9wb3ZlclBvc2l0aW9uKSB7XG4gICAgdGhpcy5zbWFydFBvc2l0aW9uU2VydmljZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudE91dHNpZGVDbGlja1RvQ2xvc2UnKVxuICBzZXQgb3V0c2lkZUNsaWNrQ2xvc2UoY2xpY2tUb0Nsb3NlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zbWFydEV2ZW50c1NlcnZpY2Uub3V0c2lkZUNsaWNrQ2xvc2UgPSAhIWNsaWNrVG9DbG9zZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9wb3ZlckNvbnRlbnRTY3JvbGxUb0Nsb3NlJylcbiAgc2V0IHNjcm9sbFRvQ2xvc2Uoc2Nyb2xsVG9DbG9zZTogYm9vbGVhbikge1xuICAgIHRoaXMuc21hcnRFdmVudHNTZXJ2aWNlLnNjcm9sbFRvQ2xvc2UgPSAhIXNjcm9sbFRvQ2xvc2U7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBIVE1MRG9jdW1lbnQsXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBzbWFydFBvc2l0aW9uU2VydmljZTogQ2xyUG9wb3ZlclBvc2l0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIHNtYXJ0RXZlbnRzU2VydmljZTogQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBzbWFydE9wZW5TZXJ2aWNlOiBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZVxuICApIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbnRlbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0aGlzLnNtYXJ0UG9zaXRpb25TZXJ2aWNlLnNob3VsZFJlYWxpZ24uc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zaG91bGRSZWFsaWduID0gdHJ1ZTtcbiAgICAgICAgLy8gQXZvaWQgZmxpY2tlcmluZyBvbiBpbml0aWFsaXphdGlvbiwgY2F1c2VkIGJ5IHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIHRoZVxuICAgICAgICAvLyBjaGVjay1jb2xsZWN0b3IgcGF0dGVybi5cbiAgICAgICAgaWYgKHRoaXMudmlldykge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ29wYWNpdHknLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIC8vIEhlcmUgd2UgY29sbGVjdCBzdWJzZXF1ZW50IHN5bmNocm9ub3VzbHkgcmVjZWl2ZWQgY29udGVudC1jaGVjayBldmVudHMgYW5kIG9ubHkgdGFrZSBhY3Rpb25cbiAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN5Y2xlLiBTZWUgYmVsb3cgZm9yIGRldGFpbHMgb24gdGhlIGNoZWNrLWNvbGxlY3RvciBwYXR0ZXJuLlxuICAgICAgdGhpcy5jaGVja0NvbGxlY3Rvci5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5hbGlnbkNvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5zaG91bGRSZWFsaWduID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICdvcGFjaXR5JywgJzEnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVDb250ZW50KCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlQ29udGVudCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnZpZXcucm9vdE5vZGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlcmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9jdW1lbnQuYm9keSwgbm9kZSkpO1xuICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgZGVsZXRlIHRoaXMudmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPKG1hdHQpOiBpbnZlc3RpZ2F0ZSB3aHkgRGVidWdFbGVtZW50IHJldGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIG5vZGVzIGFuZCBjYXVzZXMgYSBtZW1vcnkgbGVhay5cbiAgICogQSBub3RlIGFib3V0IHRoZSB1c2Ugb2YgYXBwZW5kQ2hpbGQvcmVtb3ZlQ2hpbGRcbiAgICogVGhlIERlYnVnRWxlbWVudCBpcyBrZWVwaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBkZXRhY2hlZCBub2RlIGFuZCBpdHMgdW5jbGVhciB3aHkuXG4gICAqIFRoaXMgZG9lcyB3YXJyYW50IGZ1cnRoZXIgaW52ZXN0aWdhdGlvbi4gQnV0LCBzaW5jZSBpdCBkb2Vzbid0IGhhcHBlbiBpbiBwcm9kdWN0aW9uIG1vZGVcbiAgICogaXQgaXMgYSBsb3cgcHJpb3JpdHkgaXNzdWUgZm9yIG5vdy5cbiAgICovXG4gIHByaXZhdGUgYWRkQ29udGVudCgpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHZpZXcgY29udGFpbmVyXG4gICAgdGhpcy52aWV3ID0gdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgIHRoaXMuc21hcnRFdmVudHNTZXJ2aWNlLmNvbnRlbnRSZWYgPSB0aGlzLnZpZXcucm9vdE5vZGVzWzBdOyAvLyBTbyB3ZSBrbm93IHdoZXJlL3doYXQgdG8gc2V0IGNsb3NlIGZvY3VzIG9uXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnY2xyLXBvcG92ZXItY29udGVudCcpO1xuICAgIC8vIFJlc2V0IHRvIHRoZSBiZWdpbmluZyBvZiB0aGUgZG9jdW1lbnQgdG8gYmUgYXZhaWxhYmxlIGZvciBzaXppbmcvcG9zaXRpb25pbmcgY2FsY3VsYXRpb25zLlxuICAgIC8vIElmIHdlIGFkZCBuZXcgY29udGVudCB0byB0aGUgYm90dG9tIGl0IHRyaWdnZXJzIGNoYW5nZXMgaW4gdGhlIGxheW91dCB0aGF0IG1heSBsZWFkIHRvIGZhbHNlIGFuY2hvclxuICAgIC8vIGNvb3JkaW5hdGVzIHZhbHVlcy5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICd0b3AnLCAnMHB4Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnbGVmdCcsICcwcHgnKTtcbiAgICAvLyBXZSBuZWVkIHRvIGhpZGUgaXQgZHVyaW5nIHRoZSBjYWxjdWxhdGlvbiBwaGFzZSwgd2hpbGUgaXQncyBub3QgeWV0IGZpbmFsbHkgcG9zaXRpb25lZC5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICdvcGFjaXR5JywgJzAnKTtcbiAgICB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICB0aGlzLnNtYXJ0T3BlblNlcnZpY2Uub3BlbkV2ZW50ID0gZXZlbnQ7XG4gICAgfSk7XG4gICAgdGhpcy52aWV3LnJvb3ROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIG5vZGUpO1xuICAgIH0pO1xuICAgIC8vIE1hcmsgZm9yIHJlYWxpbmdtZW50IG9uIHRoZSBuZXh0IGNvbnRlbnQtY2hlY2sgY3ljbGUuXG4gICAgdGhpcy5zaG91bGRSZWFsaWduID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkUmVhbGlnbiA9IGZhbHNlO1xuXG4gIC8vIENoZWNrLWNvbGxlY3RvciBwYXR0ZXJuOlxuICAvLyBJbiBvcmRlciB0byBnZXQgYWNjdXJhdGUgY29udGVudCBoZWlnaHQvd2lkdGggdmFsdWVzLCB3ZSBjYW5ub3QgY2FsY3VsYXRlIGFsaWdubWVudCBvZmZzZXRzIHVudGlsXG4gIC8vIGFmdGVyIHRoZSBwcm9qZWN0ZWQgY29udGVudCBoYXMgc3RhYmlsaXplZC5cbiAgLy8gQXMgbXVsdGlwbGUgY2hlY2sgZXZlbnRzIG1heSBoYXBwZW4gaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGN5Y2xlLCB3ZSBuZWVkIHRvIGNvbGxlY3QgYWxsIGV2ZW50c1xuICAvLyBhbmQgb25seSBhY3QgYWZ0ZXIgdGhlIGNvbnRlbnQgaXMgcmVhbGx5IHN0YWJsZS4gT3Igd2UgbWF5IGdldCB3cm9uZyBpbnRlcm1lZGlhdGUgcG9zaXRpb25pbmcgdmFsdWVzLlxuICAvLyBXZSB3aWxsIGNoYW5uZWwgc3Vic2VxdWVudCBjb250ZW50IGNoZWNrIGV2ZW50cyB0aHJvdWdoIHRoaXMgb2JzZXJ2YWJsZS5cbiAgcHJpdmF0ZSBjaGVja0NvbGxlY3RvcjogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW4gJiYgdGhpcy52aWV3ICYmIHRoaXMuc2hvdWxkUmVhbGlnbikge1xuICAgICAgLy8gQ2hhbm5lbCBjb250ZW50LWNoZWNrIGV2ZW50IHRocm91Z2ggdGhlIGNoZWNrLWNvbGxlY3RvclxuICAgICAgdGhpcy5jaGVja0NvbGxlY3Rvci5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhbGlnbkNvbnRlbnQoKSB7XG4gICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25Db29yZHMgPSB0aGlzLnNtYXJ0UG9zaXRpb25TZXJ2aWNlLmFsaWduQ29udGVudCh0aGlzLnZpZXcucm9vdE5vZGVzWzBdKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICd0b3AnLCBgJHtwb3NpdGlvbkNvb3Jkcy55T2Zmc2V0fXB4YCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnbGVmdCcsIGAke3Bvc2l0aW9uQ29vcmRzLnhPZmZzZXR9cHhgKTtcbiAgICB0aGlzLnNtYXJ0T3BlblNlcnZpY2UucG9wb3ZlckFsaWduZWRFbWl0KHRoaXMudmlldy5yb290Tm9kZXNbMF0pO1xuICB9XG59XG4iXX0=