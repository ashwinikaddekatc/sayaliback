/**
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChild, Inject, InjectionToken } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ControlIdService } from '../common/providers/control-id.service';
import { ClrLabel } from '../common/label';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/label';
import * as ɵngcc3 from 'rxjs';

function ClrCheckboxWrapper_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
const _c0 = [[["", "clrCheckbox", ""], ["", "clrToggle", ""]], [["label"]]];
const _c1 = ["[clrCheckbox],[clrToggle]", "label"];
export const IS_TOGGLE = new InjectionToken('IS_TOGGLE');
export function isToggleFactory() {
    return new BehaviorSubject(false);
}
export const IS_TOGGLE_PROVIDER = { provide: IS_TOGGLE, useFactory: isToggleFactory };
export class ClrCheckboxWrapper {
    constructor(toggleService) {
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
        this.toggle = false;
        this.subscriptions = [];
        this.subscriptions.push(toggleService.subscribe(state => {
            this.toggle = state;
        }));
    }
    ngOnInit() {
        if (this.label) {
            this.label.disableGrid();
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrCheckboxWrapper.ɵfac = function ClrCheckboxWrapper_Factory(t) { return new (t || ClrCheckboxWrapper)(ɵngcc0.ɵɵdirectiveInject(IS_TOGGLE)); };
ClrCheckboxWrapper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrCheckboxWrapper, selectors: [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], contentQueries: function ClrCheckboxWrapper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ClrLabel, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } }, hostVars: 4, hostBindings: function ClrCheckboxWrapper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-checkbox-wrapper", !ctx.toggle)("clr-toggle-wrapper", ctx.toggle);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ControlIdService, IS_TOGGLE_PROVIDER])], ngContentSelectors: _c1, decls: 3, vars: 1, consts: [[4, "ngIf"]], template: function ClrCheckboxWrapper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵtemplate(2, ClrCheckboxWrapper_label_2_Template, 1, 0, "label", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.ClrLabel], encapsulation: 2 });
ClrCheckboxWrapper.ctorParameters = () => [
    { type: BehaviorSubject, decorators: [{ type: Inject, args: [IS_TOGGLE,] }] }
];
ClrCheckboxWrapper.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClrCheckboxWrapper, [{
        type: Component,
        args: [{
                selector: 'clr-checkbox-wrapper,clr-toggle-wrapper',
                template: `
    <ng-content select="[clrCheckbox],[clrToggle]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
                host: {
                    '[class.clr-checkbox-wrapper]': '!toggle',
                    '[class.clr-toggle-wrapper]': 'toggle'
                },
                providers: [ControlIdService, IS_TOGGLE_PROVIDER]
            }]
    }], function () { return [{ type: ɵngcc3.BehaviorSubject, decorators: [{
                type: Inject,
                args: [IS_TOGGLE]
            }] }]; }, { label: [{
            type: ContentChild,
            args: [ClrLabel, { static: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3gtd3JhcHBlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2xyLWFuZ3VsYXIvc3JjL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LXdyYXBwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBVSxZQUFZLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsZUFBZSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUdyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7Ozs7O0FBRTNDLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBMkIsV0FBVyxDQUFDLENBQUM7QUFDbkYsTUFBTSxVQUFVLGVBQWU7QUFDL0IsSUFBRSxPQUFPLElBQUksZUFBZSxDQUFVLEtBQUssQ0FBQyxDQUFDO0FBQzdDLENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxDQUFDO0FBZXRGLE1BQU0sT0FBTyxrQkFBa0I7QUFBRyxJQVVoQyxZQUErQixhQUF1QztBQUN4RSxRQVZFLGtGQUFrRjtBQUNwRixRQUFFLHNGQUFzRjtBQUN4RixRQUFFLHdDQUF3QztBQUMxQyxRQUFFLGFBQVEsR0FBRyxLQUFLLENBQUM7QUFDbkIsUUFFRSxXQUFNLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFFBQVUsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0FBQzdDLFFBRUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLGFBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDdEMsWUFBUSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUM1QixRQUFNLENBQUMsQ0FBQyxDQUNILENBQUM7QUFDTixJQUFFLENBQUM7QUFDSCxJQUNFLFFBQVE7QUFDVixRQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNwQixZQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDL0IsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0UsV0FBVztBQUNiLFFBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUN6RCxJQUFFLENBQUM7QUFDSDs4Q0F4Q0MsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSx5Q0FBeUM7TUFDbkQsUUFBUSxFQUFFLHNKQUlULGtCQUNELElBQUksRUFBRSxzQkFDSjtNQUE4QixFQUFFLFNBQVMsc0JBQ3pDO2FBQTRCLEVBQUU7R0FBUTtNQUN2QyxrQkFDRCxTQUFTLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxrQkFBa0IsQ0FBQztHQUNsRDs7Ozs7Ozs7Ozt5RUFDSTtBQUFDO0FBQTRDLFlBekJ6QyxlQUFlLHVCQW1DVCxNQUFNLFNBQUMsU0FBUztBQUFRO0FBQUc7QUFDdEMsb0JBTkQsWUFBWSxTQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5leHBvcnQgY29uc3QgSVNfVE9HR0xFID0gbmV3IEluamVjdGlvblRva2VuPEJlaGF2aW9yU3ViamVjdDxib29sZWFuPj4oJ0lTX1RPR0dMRScpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9nZ2xlRmFjdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xufVxuZXhwb3J0IGNvbnN0IElTX1RPR0dMRV9QUk9WSURFUiA9IHsgcHJvdmlkZTogSVNfVE9HR0xFLCB1c2VGYWN0b3J5OiBpc1RvZ2dsZUZhY3RvcnkgfTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94LXdyYXBwZXIsY2xyLXRvZ2dsZS13cmFwcGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyQ2hlY2tib3hdLFtjbHJUb2dnbGVdXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbFwiPjwvbGFiZWw+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1jaGVja2JveC13cmFwcGVyXSc6ICchdG9nZ2xlJyxcbiAgICAnW2NsYXNzLmNsci10b2dnbGUtd3JhcHBlcl0nOiAndG9nZ2xlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbQ29udHJvbElkU2VydmljZSwgSVNfVE9HR0xFX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hXcmFwcGVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwsIHsgc3RhdGljOiB0cnVlIH0pXG4gIGxhYmVsOiBDbHJMYWJlbDtcbiAgdG9nZ2xlID0gZmFsc2U7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KElTX1RPR0dMRSkgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0b2dnbGVTZXJ2aWNlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlID0gc3RhdGU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5kaXNhYmxlR3JpZCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiJdfQ==