import { InjectionToken, Directive, Host, Inject, Injector, Input, KeyValueDiffers, Optional, Renderer2, Component, ComponentFactoryResolver, EventEmitter, Output, ViewContainerRef, SimpleChange, ANALYZE_FOR_ENTRY_COMPONENTS, NgModule } from '@angular/core';
import { NgComponentOutlet, CommonModule } from '@angular/common';
import { takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
const /** @type {?} */ COMPONENT_INJECTOR = new InjectionToken('ComponentInjector');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ComponentOutletInjectorDirective {
    /**
     * @param {?} componentOutlet
     */
    constructor(componentOutlet) {
        this.componentOutlet = componentOutlet;
    }
    /**
     * @return {?}
     */
    get componentRef() {
        return (/** @type {?} */ (this.componentOutlet))._componentRef;
    }
}
ComponentOutletInjectorDirective.ɵfac = function ComponentOutletInjectorDirective_Factory(t) { return new (t || ComponentOutletInjectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgComponentOutlet, 1)); };
ComponentOutletInjectorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ComponentOutletInjectorDirective, selectors: [["", "ngComponentOutlet", ""]], exportAs: ["ndcComponentOutletInjector"] });
/** @nocollapse */
ComponentOutletInjectorDirective.ctorParameters = () => [
    { type: NgComponentOutlet, decorators: [{ type: Host },] },
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ComponentOutletInjectorDirective, [{
        type: Directive,
        args: [{
                selector: '[ngComponentOutlet]',
                exportAs: 'ndcComponentOutletInjector'
            }]
    }], function () { return [{ type: ɵngcc1.NgComponentOutlet, decorators: [{
                type: Host
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DynamicAttributesDirective {
    /**
     * @param {?} renderer
     * @param {?} differs
     * @param {?} injector
     * @param {?} componentInjectorType
     * @param {?} componentOutletInjector
     */
    constructor(renderer, differs, injector, componentInjectorType, componentOutletInjector) {
        this.renderer = renderer;
        this.differs = differs;
        this.injector = injector;
        this.componentInjectorType = componentInjectorType;
        this.componentOutletInjector = componentOutletInjector;
        this._attrsDiffer = this.differs.find({}).create();
        this._componentInjector = this.injector.get(this.componentInjectorType, null);
    }
    /**
     * @return {?}
     */
    get _attributes() {
        return (this.ndcDynamicAttributes || this.ngComponentOutletNdcDynamicAttributes);
    }
    /**
     * @return {?}
     */
    get _compInjector() {
        return this.componentOutletInjector || this._componentInjector;
    }
    /**
     * @return {?}
     */
    get _nativeElement() {
        return this._compInjector.componentRef.location.nativeElement;
    }
    /**
     * @return {?}
     */
    get _compType() {
        return this._compInjector.componentRef.componentType;
    }
    /**
     * @return {?}
     */
    get _isCompChanged() {
        if (this._lastCompType !== this._compType) {
            this._lastCompType = this._compType;
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        const /** @type {?} */ isCompChanged = this._isCompChanged;
        const /** @type {?} */ changes = this._attrsDiffer.diff(this._attributes);
        if (changes) {
            this._lastAttrActions = this._changesToAttrActions(changes);
        }
        if (changes || (isCompChanged && this._lastAttrActions)) {
            this._updateAttributes(this._lastAttrActions);
        }
    }
    /**
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    setAttribute(name, value, namespace) {
        this.renderer.setAttribute(this._nativeElement, name, value, namespace);
    }
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    removeAttribute(name, namespace) {
        this.renderer.removeAttribute(this._nativeElement, name, namespace);
    }
    /**
     * @param {?} actions
     * @return {?}
     */
    _updateAttributes(actions) {
        Object.keys(actions.set).forEach(key => this.setAttribute(key, actions.set[key]));
        actions.remove.forEach(key => this.removeAttribute(key));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    _changesToAttrActions(changes) {
        const /** @type {?} */ attrActions = {
            set: {},
            remove: [],
        };
        changes.forEachAddedItem(r => (attrActions.set[r.key] = r.currentValue));
        changes.forEachChangedItem(r => (attrActions.set[r.key] = r.currentValue));
        changes.forEachRemovedItem(r => attrActions.remove.push(r.key));
        return attrActions;
    }
}
DynamicAttributesDirective.ɵfac = function DynamicAttributesDirective_Factory(t) { return new (t || DynamicAttributesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(COMPONENT_INJECTOR), ɵngcc0.ɵɵdirectiveInject(ComponentOutletInjectorDirective, 9)); };
DynamicAttributesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DynamicAttributesDirective, selectors: [["", "ndcDynamicAttributes", ""], ["", "ngComponentOutletNdcDynamicAttributes", ""]], inputs: { ndcDynamicAttributes: "ndcDynamicAttributes", ngComponentOutletNdcDynamicAttributes: "ngComponentOutletNdcDynamicAttributes" }, exportAs: ["ndcDynamicAttributes"] });
/** @nocollapse */
DynamicAttributesDirective.ctorParameters = () => [
    { type: Renderer2, },
    { type: KeyValueDiffers, },
    { type: Injector, },
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_INJECTOR,] },] },
    { type: ComponentOutletInjectorDirective, decorators: [{ type: Optional }, { type: Host },] },
];
DynamicAttributesDirective.propDecorators = {
    "ndcDynamicAttributes": [{ type: Input },],
    "ngComponentOutletNdcDynamicAttributes": [{ type: Input },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DynamicAttributesDirective, [{
        type: Directive,
        args: [{
                selector: '[ndcDynamicAttributes],[ngComponentOutletNdcDynamicAttributes]',
                exportAs: 'ndcDynamicAttributes'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.Injector }, { type: undefined, decorators: [{
                type: Inject,
                args: [COMPONENT_INJECTOR]
            }] }, { type: ComponentOutletInjectorDirective, decorators: [{
                type: Optional
            }, {
                type: Host
            }] }]; }, { ndcDynamicAttributes: [{
            type: Input
        }], ngComponentOutletNdcDynamicAttributes: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DynamicComponent {
    /**
     * @param {?} _vcr
     * @param {?} _cfr
     */
    constructor(_vcr, _cfr) {
        this._vcr = _vcr;
        this._cfr = _cfr;
        this.ndcDynamicCreated = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['ndcDynamicComponent']) {
            this.createDynamicComponent();
        }
    }
    /**
     * @return {?}
     */
    createDynamicComponent() {
        this._vcr.clear();
        this.componentRef = null;
        if (this.ndcDynamicComponent) {
            this.componentRef = this._vcr.createComponent(this._cfr.resolveComponentFactory(this.ndcDynamicComponent), 0, this._resolveInjector(), this.ndcDynamicContent);
            this.ndcDynamicCreated.emit(this.componentRef);
        }
    }
    /**
     * @return {?}
     */
    _resolveInjector() {
        let /** @type {?} */ injector = this.ndcDynamicInjector || this._vcr.parentInjector;
        if (this.ndcDynamicProviders) {
            injector = Injector.create({
                providers: this.ndcDynamicProviders,
                parent: injector,
            });
        }
        return injector;
    }
}
DynamicComponent.ɵfac = function DynamicComponent_Factory(t) { return new (t || DynamicComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
DynamicComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DynamicComponent, selectors: [["ndc-dynamic"]], inputs: { ndcDynamicComponent: "ndcDynamicComponent", ndcDynamicInjector: "ndcDynamicInjector", ndcDynamicProviders: "ndcDynamicProviders", ndcDynamicContent: "ndcDynamicContent" }, outputs: { ndcDynamicCreated: "ndcDynamicCreated" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function DynamicComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
DynamicComponent.ctorParameters = () => [
    { type: ViewContainerRef, },
    { type: ComponentFactoryResolver, },
];
DynamicComponent.propDecorators = {
    "ndcDynamicComponent": [{ type: Input },],
    "ndcDynamicInjector": [{ type: Input },],
    "ndcDynamicProviders": [{ type: Input },],
    "ndcDynamicContent": [{ type: Input },],
    "ndcDynamicCreated": [{ type: Output },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DynamicComponent, [{
        type: Component,
        args: [{
                selector: 'ndc-dynamic',
                template: ''
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, { ndcDynamicCreated: [{
            type: Output
        }], ndcDynamicComponent: [{
            type: Input
        }], ndcDynamicInjector: [{
            type: Input
        }], ndcDynamicProviders: [{
            type: Input
        }], ndcDynamicContent: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function createNewChange(val) {
    return new SimpleChange(undefined, val, true);
}
/**
 * @param {?} record
 * @param {?=} isFirstChange
 * @return {?}
 */
function recordToChange(record, isFirstChange = false) {
    return isFirstChange
        ? createNewChange(record.currentValue)
        : new SimpleChange(record.previousValue, record.currentValue, false);
}
/**
 * @param {?} isFirstChanges
 * @param {?} setter
 * @return {?}
 */
function setChangeFromRecord(isFirstChanges, setter) {
    return (record) => setter(record, recordToChange(record, isFirstChanges));
}
/**
 * @param {?} isFirstChanges
 * @return {?}
 */
function getChangesRecords(isFirstChanges) {
    return (changes) => setChangeFromRecord(isFirstChanges, (record, change) => changes[record.key] = change);
}
/**
 * @param {?} isFirstChanges
 * @return {?}
 */
function getNewChangesRecords(isFirstChanges) {
    return (changes) => setChangeFromRecord(isFirstChanges, (record, change) => {
        if (!changes[record.key]) {
            changes[record.key] = change;
        }
    });
}
const /** @type {?} */ defaultOpts = {
    isFirstChanges: false,
    onlyNewChanges: false,
};
/**
 * @param {?=} opts
 * @return {?}
 */
function changesFromRecord(opts = defaultOpts) {
    return opts.onlyNewChanges
        ? getNewChangesRecords(opts.isFirstChanges)
        : getChangesRecords(opts.isFirstChanges);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ recordToChanges = changesFromRecord({ isFirstChanges: true });
const /** @type {?} */ recordToNewChanges = changesFromRecord({ onlyNewChanges: true });
class DynamicDirective {
    /**
     * @param {?} _differs
     * @param {?} _injector
     * @param {?} _cfr
     * @param {?} _componentInjectorType
     * @param {?} _componentOutletInjector
     */
    constructor(_differs, _injector, _cfr, _componentInjectorType, _componentOutletInjector) {
        this._differs = _differs;
        this._injector = _injector;
        this._cfr = _cfr;
        this._componentInjectorType = _componentInjectorType;
        this._componentOutletInjector = _componentOutletInjector;
        this._componentInjector = this._injector.get(this._componentInjectorType, null);
        this._lastComponentInst = this._componentInjector;
        this._inputsDiffer = this._differs.find({}).create();
        this._compFactory = null;
        this._outputsShouldDisconnect$ = new Subject();
    }
    /**
     * @return {?}
     */
    get _inputs() {
        return this.ndcDynamicInputs || this.ngComponentOutletNdcDynamicInputs;
    }
    /**
     * @return {?}
     */
    get _outputs() {
        return this.ndcDynamicOutputs || this.ngComponentOutletNdcDynamicOutputs;
    }
    /**
     * @return {?}
     */
    get _compInjector() {
        return this._componentOutletInjector || this._componentInjector;
    }
    /**
     * @return {?}
     */
    get _compRef() {
        return this._compInjector.componentRef;
    }
    /**
     * @return {?}
     */
    get _componentInst() {
        return this._compRef.instance;
    }
    /**
     * @return {?}
     */
    get _componentInstChanged() {
        if (this._lastComponentInst !== this._componentInst) {
            this._lastComponentInst = this._componentInst;
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ compChanged = this._componentInstChanged;
        if (compChanged || this._inputsChanged(changes)) {
            const /** @type {?} */ inputsChanges = this._getInputsChanges(this._inputs);
            if (inputsChanges) {
                this._updateInputChanges(inputsChanges);
            }
            this.updateInputs(compChanged || !this._lastInputChanges);
        }
        if (compChanged || this._outputsChanged(changes)) {
            this.bindOutputs();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._componentInstChanged) {
            this.updateInputs(true);
            this.bindOutputs();
            return;
        }
        const /** @type {?} */ inputs = this._inputs;
        if (!inputs) {
            return;
        }
        const /** @type {?} */ inputsChanges = this._getInputsChanges(this._inputs);
        if (inputsChanges) {
            const /** @type {?} */ isNotFirstChange = !!this._lastInputChanges;
            this._updateInputChanges(inputsChanges);
            if (isNotFirstChange) {
                this.updateInputs();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._disconnectOutputs();
    }
    /**
     * @param {?=} isFirstChange
     * @return {?}
     */
    updateInputs(isFirstChange = false) {
        if (isFirstChange) {
            this._updateCompFactory();
        }
        const /** @type {?} */ compInst = this._componentInst;
        let /** @type {?} */ inputs = this._inputs;
        if (!inputs || !compInst) {
            return;
        }
        inputs = this._resolveInputs(inputs);
        Object.keys(inputs).forEach(p => (compInst[p] = inputs[p]));
        this.notifyOnInputChanges(this._lastInputChanges, isFirstChange);
    }
    /**
     * @return {?}
     */
    bindOutputs() {
        this._disconnectOutputs();
        const /** @type {?} */ compInst = this._componentInst;
        let /** @type {?} */ outputs = this._outputs;
        if (!outputs || !compInst) {
            return;
        }
        outputs = this._resolveOutputs(outputs);
        Object.keys(outputs)
            .filter(p => compInst[p])
            .forEach(p => compInst[p]
            .pipe(takeUntil(this._outputsShouldDisconnect$))
            .subscribe(outputs[p]));
    }
    /**
     * @param {?=} changes
     * @param {?=} forceFirstChanges
     * @return {?}
     */
    notifyOnInputChanges(changes = {}, forceFirstChanges) {
        // Exit early if component not interested to receive changes
        if (!this._componentInst.ngOnChanges) {
            return;
        }
        if (forceFirstChanges) {
            changes = this._collectFirstChanges();
        }
        this._componentInst.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    _disconnectOutputs() {
        this._outputsShouldDisconnect$.next();
    }
    /**
     * @param {?} inputs
     * @return {?}
     */
    _getInputsChanges(inputs) {
        return this._inputsDiffer.diff(this._inputs);
    }
    /**
     * @param {?} differ
     * @return {?}
     */
    _updateInputChanges(differ) {
        this._lastInputChanges = this._collectChangesFromDiffer(differ);
    }
    /**
     * @return {?}
     */
    _collectFirstChanges() {
        const /** @type {?} */ changes = /** @type {?} */ ({});
        const /** @type {?} */ inputs = this._inputs;
        Object.keys(inputs).forEach(prop => (changes[prop] = createNewChange(inputs[prop])));
        return this._resolveChanges(changes);
    }
    /**
     * @param {?} differ
     * @return {?}
     */
    _collectChangesFromDiffer(differ) {
        const /** @type {?} */ changes = /** @type {?} */ ({});
        differ.forEachAddedItem(recordToChanges(changes));
        differ.forEachItem(recordToNewChanges(changes));
        return this._resolveChanges(changes);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    _inputsChanged(changes) {
        return ('ngComponentOutletNdcDynamicInputs' in changes ||
            'ndcDynamicInputs' in changes);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    _outputsChanged(changes) {
        return ('ngComponentOutletNdcDynamicOutputs' in changes ||
            'ndcDynamicOutputs' in changes);
    }
    /**
     * @return {?}
     */
    _resolveCompFactory() {
        try {
            try {
                return this._cfr.resolveComponentFactory(this._compRef.componentType);
            }
            catch (/** @type {?} */ e) {
                // Fallback if componentType does not exist (happens on NgComponentOutlet)
                return this._cfr.resolveComponentFactory(this._compRef.instance.constructor);
            }
        }
        catch (/** @type {?} */ e) {
            // Factory not available - bailout
            return null;
        }
    }
    /**
     * @return {?}
     */
    _updateCompFactory() {
        this._compFactory = this._resolveCompFactory();
    }
    /**
     * @param {?} inputs
     * @return {?}
     */
    _resolveInputs(inputs) {
        if (!this._compFactory) {
            return inputs;
        }
        return this._remapIO(inputs, this._compFactory.inputs);
    }
    /**
     * @param {?} outputs
     * @return {?}
     */
    _resolveOutputs(outputs) {
        if (!this._compFactory) {
            return outputs;
        }
        return this._remapIO(outputs, this._compFactory.outputs);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    _resolveChanges(changes) {
        if (!this._compFactory) {
            return changes;
        }
        return this._remapIO(changes, this._compFactory.inputs);
    }
    /**
     * @param {?} io
     * @param {?} mapping
     * @return {?}
     */
    _remapIO(io, mapping) {
        const /** @type {?} */ newIO = {};
        Object.keys(io).forEach(key => {
            const /** @type {?} */ newKey = this._findPropByTplInMapping(key, mapping) || key;
            newIO[newKey] = io[key];
        });
        return newIO;
    }
    /**
     * @param {?} tplName
     * @param {?} mapping
     * @return {?}
     */
    _findPropByTplInMapping(tplName, mapping) {
        for (const /** @type {?} */ map of mapping) {
            if (map.templateName === tplName) {
                return map.propName;
            }
        }
        return null;
    }
}
DynamicDirective.ɵfac = function DynamicDirective_Factory(t) { return new (t || DynamicDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(COMPONENT_INJECTOR), ɵngcc0.ɵɵdirectiveInject(ComponentOutletInjectorDirective, 9)); };
DynamicDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DynamicDirective, selectors: [["", "ndcDynamicInputs", ""], ["", "ndcDynamicOutputs", ""], ["", "ngComponentOutletNdcDynamicInputs", ""], ["", "ngComponentOutletNdcDynamicOutputs", ""]], inputs: { ndcDynamicInputs: "ndcDynamicInputs", ngComponentOutletNdcDynamicInputs: "ngComponentOutletNdcDynamicInputs", ndcDynamicOutputs: "ndcDynamicOutputs", ngComponentOutletNdcDynamicOutputs: "ngComponentOutletNdcDynamicOutputs" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
DynamicDirective.ctorParameters = () => [
    { type: KeyValueDiffers, },
    { type: Injector, },
    { type: ComponentFactoryResolver, },
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_INJECTOR,] },] },
    { type: ComponentOutletInjectorDirective, decorators: [{ type: Host }, { type: Optional },] },
];
DynamicDirective.propDecorators = {
    "ndcDynamicInputs": [{ type: Input },],
    "ngComponentOutletNdcDynamicInputs": [{ type: Input },],
    "ndcDynamicOutputs": [{ type: Input },],
    "ngComponentOutletNdcDynamicOutputs": [{ type: Input },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DynamicDirective, [{
        type: Directive,
        args: [{
                selector: '[ndcDynamicInputs],[ndcDynamicOutputs],[ngComponentOutletNdcDynamicInputs],[ngComponentOutletNdcDynamicOutputs]'
            }]
    }], function () { return [{ type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [COMPONENT_INJECTOR]
            }] }, { type: ComponentOutletInjectorDirective, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }]; }, { ndcDynamicInputs: [{
            type: Input
        }], ngComponentOutletNdcDynamicInputs: [{
            type: Input
        }], ndcDynamicOutputs: [{
            type: Input
        }], ngComponentOutletNdcDynamicOutputs: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DynamicModule {
    /**
     * @param {?} components
     * @param {?=} componentInjector
     * @return {?}
     */
    static withComponents(components, componentInjector = DynamicComponent) {
        return {
            ngModule: DynamicModule,
            providers: [
                {
                    provide: ANALYZE_FOR_ENTRY_COMPONENTS,
                    useValue: components,
                    multi: true,
                },
                { provide: COMPONENT_INJECTOR, useValue: componentInjector },
            ],
        };
    }
}
DynamicModule.ɵfac = function DynamicModule_Factory(t) { return new (t || DynamicModule)(); };
DynamicModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DynamicModule });
DynamicModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DynamicModule, { declarations: function () { return [DynamicComponent, DynamicDirective, ComponentOutletInjectorDirective, DynamicAttributesDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DynamicComponent, DynamicDirective, ComponentOutletInjectorDirective, DynamicAttributesDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DynamicModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [
                    DynamicComponent,
                    DynamicDirective,
                    ComponentOutletInjectorDirective,
                    DynamicAttributesDirective,
                ],
                exports: [
                    DynamicComponent,
                    DynamicDirective,
                    ComponentOutletInjectorDirective,
                    DynamicAttributesDirective,
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { DynamicModule, DynamicDirective, DynamicComponent, DynamicAttributesDirective, COMPONENT_INJECTOR as ɵa, ComponentOutletInjectorDirective as ɵb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctZHluYW1pYy1jb21wb25lbnQuZXMyMDE1LmpzIiwic291cmNlcyI6WyJuZy1keW5hbWljLWNvbXBvbmVudC5lczIwMTUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttTUFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVhBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrZEFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJnQkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWlCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgRGlyZWN0aXZlLCBIb3N0LCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgS2V5VmFsdWVEaWZmZXJzLCBPcHRpb25hbCwgUmVuZGVyZXIyLCBDb21wb25lbnQsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIFZpZXdDb250YWluZXJSZWYsIFNpbXBsZUNoYW5nZSwgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29tcG9uZW50T3V0bGV0LCBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jb25zdCAvKiogQHR5cGUgez99ICovIENPTVBPTkVOVF9JTkpFQ1RPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignQ29tcG9uZW50SW5qZWN0b3InKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuY2xhc3MgQ29tcG9uZW50T3V0bGV0SW5qZWN0b3JEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50T3V0bGV0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50T3V0bGV0KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50T3V0bGV0ID0gY29tcG9uZW50T3V0bGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBjb21wb25lbnRSZWYoKSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jb21wb25lbnRPdXRsZXQpKS5fY29tcG9uZW50UmVmO1xuICAgIH1cbn1cbkNvbXBvbmVudE91dGxldEluamVjdG9yRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmdDb21wb25lbnRPdXRsZXRdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ25kY0NvbXBvbmVudE91dGxldEluamVjdG9yJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29tcG9uZW50T3V0bGV0SW5qZWN0b3JEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ0NvbXBvbmVudE91dGxldCwgZGVjb3JhdG9yczogW3sgdHlwZTogSG9zdCB9LF0gfSxcbl07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmNsYXNzIER5bmFtaWNBdHRyaWJ1dGVzRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBkaWZmZXJzXG4gICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SW5qZWN0b3JUeXBlXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRPdXRsZXRJbmplY3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBkaWZmZXJzLCBpbmplY3RvciwgY29tcG9uZW50SW5qZWN0b3JUeXBlLCBjb21wb25lbnRPdXRsZXRJbmplY3Rvcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZGlmZmVycyA9IGRpZmZlcnM7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbmplY3RvclR5cGUgPSBjb21wb25lbnRJbmplY3RvclR5cGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50T3V0bGV0SW5qZWN0b3IgPSBjb21wb25lbnRPdXRsZXRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5fYXR0cnNEaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZCh7fSkuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEluamVjdG9yID0gdGhpcy5pbmplY3Rvci5nZXQodGhpcy5jb21wb25lbnRJbmplY3RvclR5cGUsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5kY0R5bmFtaWNBdHRyaWJ1dGVzIHx8IHRoaXMubmdDb21wb25lbnRPdXRsZXROZGNEeW5hbWljQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IF9jb21wSW5qZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudE91dGxldEluamVjdG9yIHx8IHRoaXMuX2NvbXBvbmVudEluamVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBJbmplY3Rvci5jb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgX2NvbXBUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcEluamVjdG9yLmNvbXBvbmVudFJlZi5jb21wb25lbnRUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfaXNDb21wQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RDb21wVHlwZSAhPT0gdGhpcy5fY29tcFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RDb21wVHlwZSA9IHRoaXMuX2NvbXBUeXBlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgY29uc3QgLyoqIEB0eXBlIHs/fSAqLyBpc0NvbXBDaGFuZ2VkID0gdGhpcy5faXNDb21wQ2hhbmdlZDtcbiAgICAgICAgY29uc3QgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VzID0gdGhpcy5fYXR0cnNEaWZmZXIuZGlmZih0aGlzLl9hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RBdHRyQWN0aW9ucyA9IHRoaXMuX2NoYW5nZXNUb0F0dHJBY3Rpb25zKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzIHx8IChpc0NvbXBDaGFuZ2VkICYmIHRoaXMuX2xhc3RBdHRyQWN0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZXModGhpcy5fbGFzdEF0dHJBY3Rpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9uYXRpdmVFbGVtZW50LCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICByZW1vdmVBdHRyaWJ1dGUobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuX25hdGl2ZUVsZW1lbnQsIG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX3VwZGF0ZUF0dHJpYnV0ZXMoYWN0aW9ucykge1xuICAgICAgICBPYmplY3Qua2V5cyhhY3Rpb25zLnNldCkuZm9yRWFjaChrZXkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBhY3Rpb25zLnNldFtrZXldKSk7XG4gICAgICAgIGFjdGlvbnMucmVtb3ZlLmZvckVhY2goa2V5ID0+IHRoaXMucmVtb3ZlQXR0cmlidXRlKGtleSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jaGFuZ2VzVG9BdHRyQWN0aW9ucyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gYXR0ckFjdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXQ6IHt9LFxuICAgICAgICAgICAgcmVtb3ZlOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKHIgPT4gKGF0dHJBY3Rpb25zLnNldFtyLmtleV0gPSByLmN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShyID0+IChhdHRyQWN0aW9ucy5zZXRbci5rZXldID0gci5jdXJyZW50VmFsdWUpKTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0ociA9PiBhdHRyQWN0aW9ucy5yZW1vdmUucHVzaChyLmtleSkpO1xuICAgICAgICByZXR1cm4gYXR0ckFjdGlvbnM7XG4gICAgfVxufVxuRHluYW1pY0F0dHJpYnV0ZXNEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZGNEeW5hbWljQXR0cmlidXRlc10sW25nQ29tcG9uZW50T3V0bGV0TmRjRHluYW1pY0F0dHJpYnV0ZXNdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ25kY0R5bmFtaWNBdHRyaWJ1dGVzJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHluYW1pY0F0dHJpYnV0ZXNEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBLZXlWYWx1ZURpZmZlcnMsIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbQ09NUE9ORU5UX0lOSkVDVE9SLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRPdXRsZXRJbmplY3RvckRpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBIb3N0IH0sXSB9LFxuXTtcbkR5bmFtaWNBdHRyaWJ1dGVzRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIFwibmRjRHluYW1pY0F0dHJpYnV0ZXNcIjogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgIFwibmdDb21wb25lbnRPdXRsZXROZGNEeW5hbWljQXR0cmlidXRlc1wiOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jbGFzcyBEeW5hbWljQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF92Y3JcbiAgICAgKiBAcGFyYW0gez99IF9jZnJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdmNyLCBfY2ZyKSB7XG4gICAgICAgIHRoaXMuX3ZjciA9IF92Y3I7XG4gICAgICAgIHRoaXMuX2NmciA9IF9jZnI7XG4gICAgICAgIHRoaXMubmRjRHluYW1pY0NyZWF0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbmRjRHluYW1pY0NvbXBvbmVudCddKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUR5bmFtaWNDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGNyZWF0ZUR5bmFtaWNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuX3Zjci5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5kY0R5bmFtaWNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gdGhpcy5fdmNyLmNyZWF0ZUNvbXBvbmVudCh0aGlzLl9jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkodGhpcy5uZGNEeW5hbWljQ29tcG9uZW50KSwgMCwgdGhpcy5fcmVzb2x2ZUluamVjdG9yKCksIHRoaXMubmRjRHluYW1pY0NvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5uZGNEeW5hbWljQ3JlYXRlZC5lbWl0KHRoaXMuY29tcG9uZW50UmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9yZXNvbHZlSW5qZWN0b3IoKSB7XG4gICAgICAgIGxldCAvKiogQHR5cGUgez99ICovIGluamVjdG9yID0gdGhpcy5uZGNEeW5hbWljSW5qZWN0b3IgfHwgdGhpcy5fdmNyLnBhcmVudEluamVjdG9yO1xuICAgICAgICBpZiAodGhpcy5uZGNEeW5hbWljUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiB0aGlzLm5kY0R5bmFtaWNQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbmplY3RvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmplY3RvcjtcbiAgICB9XG59XG5EeW5hbWljQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduZGMtZHluYW1pYycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkR5bmFtaWNDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCB9LFxuXTtcbkR5bmFtaWNDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgXCJuZGNEeW5hbWljQ29tcG9uZW50XCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICBcIm5kY0R5bmFtaWNJbmplY3RvclwiOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgXCJuZGNEeW5hbWljUHJvdmlkZXJzXCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICBcIm5kY0R5bmFtaWNDb250ZW50XCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICBcIm5kY0R5bmFtaWNDcmVhdGVkXCI6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBwYXJhbSB7P30gdmFsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVOZXdDaGFuZ2UodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVDaGFuZ2UodW5kZWZpbmVkLCB2YWwsIHRydWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlY29yZFxuICogQHBhcmFtIHs/PX0gaXNGaXJzdENoYW5nZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVjb3JkVG9DaGFuZ2UocmVjb3JkLCBpc0ZpcnN0Q2hhbmdlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gaXNGaXJzdENoYW5nZVxuICAgICAgICA/IGNyZWF0ZU5ld0NoYW5nZShyZWNvcmQuY3VycmVudFZhbHVlKVxuICAgICAgICA6IG5ldyBTaW1wbGVDaGFuZ2UocmVjb3JkLnByZXZpb3VzVmFsdWUsIHJlY29yZC5jdXJyZW50VmFsdWUsIGZhbHNlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpc0ZpcnN0Q2hhbmdlc1xuICogQHBhcmFtIHs/fSBzZXR0ZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNldENoYW5nZUZyb21SZWNvcmQoaXNGaXJzdENoYW5nZXMsIHNldHRlcikge1xuICAgIHJldHVybiAocmVjb3JkKSA9PiBzZXR0ZXIocmVjb3JkLCByZWNvcmRUb0NoYW5nZShyZWNvcmQsIGlzRmlyc3RDaGFuZ2VzKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaXNGaXJzdENoYW5nZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldENoYW5nZXNSZWNvcmRzKGlzRmlyc3RDaGFuZ2VzKSB7XG4gICAgcmV0dXJuIChjaGFuZ2VzKSA9PiBzZXRDaGFuZ2VGcm9tUmVjb3JkKGlzRmlyc3RDaGFuZ2VzLCAocmVjb3JkLCBjaGFuZ2UpID0+IGNoYW5nZXNbcmVjb3JkLmtleV0gPSBjaGFuZ2UpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlzRmlyc3RDaGFuZ2VzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXROZXdDaGFuZ2VzUmVjb3Jkcyhpc0ZpcnN0Q2hhbmdlcykge1xuICAgIHJldHVybiAoY2hhbmdlcykgPT4gc2V0Q2hhbmdlRnJvbVJlY29yZChpc0ZpcnN0Q2hhbmdlcywgKHJlY29yZCwgY2hhbmdlKSA9PiB7XG4gICAgICAgIGlmICghY2hhbmdlc1tyZWNvcmQua2V5XSkge1xuICAgICAgICAgICAgY2hhbmdlc1tyZWNvcmQua2V5XSA9IGNoYW5nZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgLyoqIEB0eXBlIHs/fSAqLyBkZWZhdWx0T3B0cyA9IHtcbiAgICBpc0ZpcnN0Q2hhbmdlczogZmFsc2UsXG4gICAgb25seU5ld0NoYW5nZXM6IGZhbHNlLFxufTtcbi8qKlxuICogQHBhcmFtIHs/PX0gb3B0c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2hhbmdlc0Zyb21SZWNvcmQob3B0cyA9IGRlZmF1bHRPcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMub25seU5ld0NoYW5nZXNcbiAgICAgICAgPyBnZXROZXdDaGFuZ2VzUmVjb3JkcyhvcHRzLmlzRmlyc3RDaGFuZ2VzKVxuICAgICAgICA6IGdldENoYW5nZXNSZWNvcmRzKG9wdHMuaXNGaXJzdENoYW5nZXMpO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jb25zdCAvKiogQHR5cGUgez99ICovIHJlY29yZFRvQ2hhbmdlcyA9IGNoYW5nZXNGcm9tUmVjb3JkKHsgaXNGaXJzdENoYW5nZXM6IHRydWUgfSk7XG5jb25zdCAvKiogQHR5cGUgez99ICovIHJlY29yZFRvTmV3Q2hhbmdlcyA9IGNoYW5nZXNGcm9tUmVjb3JkKHsgb25seU5ld0NoYW5nZXM6IHRydWUgfSk7XG5jbGFzcyBEeW5hbWljRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaWZmZXJzXG4gICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IF9jZnJcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRJbmplY3RvclR5cGVcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRPdXRsZXRJbmplY3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9kaWZmZXJzLCBfaW5qZWN0b3IsIF9jZnIsIF9jb21wb25lbnRJbmplY3RvclR5cGUsIF9jb21wb25lbnRPdXRsZXRJbmplY3Rvcikge1xuICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9jZnIgPSBfY2ZyO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRJbmplY3RvclR5cGUgPSBfY29tcG9uZW50SW5qZWN0b3JUeXBlO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRPdXRsZXRJbmplY3RvciA9IF9jb21wb25lbnRPdXRsZXRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50SW5qZWN0b3IgPSB0aGlzLl9pbmplY3Rvci5nZXQodGhpcy5fY29tcG9uZW50SW5qZWN0b3JUeXBlLCBudWxsKTtcbiAgICAgICAgdGhpcy5fbGFzdENvbXBvbmVudEluc3QgPSB0aGlzLl9jb21wb25lbnRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5faW5wdXRzRGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHt9KS5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5fY29tcEZhY3RvcnkgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdXRwdXRzU2hvdWxkRGlzY29ubmVjdCQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfaW5wdXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZGNEeW5hbWljSW5wdXRzIHx8IHRoaXMubmdDb21wb25lbnRPdXRsZXROZGNEeW5hbWljSW5wdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfb3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmRjRHluYW1pY091dHB1dHMgfHwgdGhpcy5uZ0NvbXBvbmVudE91dGxldE5kY0R5bmFtaWNPdXRwdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfY29tcEluamVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50T3V0bGV0SW5qZWN0b3IgfHwgdGhpcy5fY29tcG9uZW50SW5qZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IF9jb21wUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcEluamVjdG9yLmNvbXBvbmVudFJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgX2NvbXBvbmVudEluc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wUmVmLmluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfY29tcG9uZW50SW5zdENoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0Q29tcG9uZW50SW5zdCAhPT0gdGhpcy5fY29tcG9uZW50SW5zdCkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdENvbXBvbmVudEluc3QgPSB0aGlzLl9jb21wb25lbnRJbnN0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gY29tcENoYW5nZWQgPSB0aGlzLl9jb21wb25lbnRJbnN0Q2hhbmdlZDtcbiAgICAgICAgaWYgKGNvbXBDaGFuZ2VkIHx8IHRoaXMuX2lucHV0c0NoYW5nZWQoY2hhbmdlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzQ2hhbmdlcyA9IHRoaXMuX2dldElucHV0c0NoYW5nZXModGhpcy5faW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHNDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5wdXRDaGFuZ2VzKGlucHV0c0NoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dHMoY29tcENoYW5nZWQgfHwgIXRoaXMuX2xhc3RJbnB1dENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wQ2hhbmdlZCB8fCB0aGlzLl9vdXRwdXRzQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kT3V0cHV0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50SW5zdENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXRzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5iaW5kT3V0cHV0cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzID0gdGhpcy5faW5wdXRzO1xuICAgICAgICBpZiAoIWlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzQ2hhbmdlcyA9IHRoaXMuX2dldElucHV0c0NoYW5nZXModGhpcy5faW5wdXRzKTtcbiAgICAgICAgaWYgKGlucHV0c0NoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gaXNOb3RGaXJzdENoYW5nZSA9ICEhdGhpcy5fbGFzdElucHV0Q2hhbmdlcztcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUlucHV0Q2hhbmdlcyhpbnB1dHNDaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmIChpc05vdEZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0T3V0cHV0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBpc0ZpcnN0Q2hhbmdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICB1cGRhdGVJbnB1dHMoaXNGaXJzdENoYW5nZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChpc0ZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb21wRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gY29tcEluc3QgPSB0aGlzLl9jb21wb25lbnRJbnN0O1xuICAgICAgICBsZXQgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHMgPSB0aGlzLl9pbnB1dHM7XG4gICAgICAgIGlmICghaW5wdXRzIHx8ICFjb21wSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0cyA9IHRoaXMuX3Jlc29sdmVJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmtleXMoaW5wdXRzKS5mb3JFYWNoKHAgPT4gKGNvbXBJbnN0W3BdID0gaW5wdXRzW3BdKSk7XG4gICAgICAgIHRoaXMubm90aWZ5T25JbnB1dENoYW5nZXModGhpcy5fbGFzdElucHV0Q2hhbmdlcywgaXNGaXJzdENoYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgYmluZE91dHB1dHMoKSB7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RPdXRwdXRzKCk7XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gY29tcEluc3QgPSB0aGlzLl9jb21wb25lbnRJbnN0O1xuICAgICAgICBsZXQgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cztcbiAgICAgICAgaWYgKCFvdXRwdXRzIHx8ICFjb21wSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMgPSB0aGlzLl9yZXNvbHZlT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgT2JqZWN0LmtleXMob3V0cHV0cylcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiBjb21wSW5zdFtwXSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHAgPT4gY29tcEluc3RbcF1cbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vdXRwdXRzU2hvdWxkRGlzY29ubmVjdCQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShvdXRwdXRzW3BdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gez89fSBmb3JjZUZpcnN0Q2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbm90aWZ5T25JbnB1dENoYW5nZXMoY2hhbmdlcyA9IHt9LCBmb3JjZUZpcnN0Q2hhbmdlcykge1xuICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIGNvbXBvbmVudCBub3QgaW50ZXJlc3RlZCB0byByZWNlaXZlIGNoYW5nZXNcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRJbnN0Lm5nT25DaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmNlRmlyc3RDaGFuZ2VzKSB7XG4gICAgICAgICAgICBjaGFuZ2VzID0gdGhpcy5fY29sbGVjdEZpcnN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEluc3QubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2Rpc2Nvbm5lY3RPdXRwdXRzKCkge1xuICAgICAgICB0aGlzLl9vdXRwdXRzU2hvdWxkRGlzY29ubmVjdCQubmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldElucHV0c0NoYW5nZXMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dHNEaWZmZXIuZGlmZih0aGlzLl9pbnB1dHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpZmZlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX3VwZGF0ZUlucHV0Q2hhbmdlcyhkaWZmZXIpIHtcbiAgICAgICAgdGhpcy5fbGFzdElucHV0Q2hhbmdlcyA9IHRoaXMuX2NvbGxlY3RDaGFuZ2VzRnJvbURpZmZlcihkaWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jb2xsZWN0Rmlyc3RDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCAvKiogQHR5cGUgez99ICovIGNoYW5nZXMgPSAvKiogQHR5cGUgez99ICovICh7fSk7XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzID0gdGhpcy5faW5wdXRzO1xuICAgICAgICBPYmplY3Qua2V5cyhpbnB1dHMpLmZvckVhY2gocHJvcCA9PiAoY2hhbmdlc1twcm9wXSA9IGNyZWF0ZU5ld0NoYW5nZShpbnB1dHNbcHJvcF0pKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaWZmZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jb2xsZWN0Q2hhbmdlc0Zyb21EaWZmZXIoZGlmZmVyKSB7XG4gICAgICAgIGNvbnN0IC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlcyA9IC8qKiBAdHlwZSB7P30gKi8gKHt9KTtcbiAgICAgICAgZGlmZmVyLmZvckVhY2hBZGRlZEl0ZW0ocmVjb3JkVG9DaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICAgICAgZGlmZmVyLmZvckVhY2hJdGVtKHJlY29yZFRvTmV3Q2hhbmdlcyhjaGFuZ2VzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfaW5wdXRzQ2hhbmdlZChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiAoJ25nQ29tcG9uZW50T3V0bGV0TmRjRHluYW1pY0lucHV0cycgaW4gY2hhbmdlcyB8fFxuICAgICAgICAgICAgJ25kY0R5bmFtaWNJbnB1dHMnIGluIGNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9vdXRwdXRzQ2hhbmdlZChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiAoJ25nQ29tcG9uZW50T3V0bGV0TmRjRHluYW1pY091dHB1dHMnIGluIGNoYW5nZXMgfHxcbiAgICAgICAgICAgICduZGNEeW5hbWljT3V0cHV0cycgaW4gY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX3Jlc29sdmVDb21wRmFjdG9yeSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLl9jb21wUmVmLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKC8qKiBAdHlwZSB7P30gKi8gZSkge1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIGNvbXBvbmVudFR5cGUgZG9lcyBub3QgZXhpc3QgKGhhcHBlbnMgb24gTmdDb21wb25lbnRPdXRsZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLl9jb21wUmVmLmluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoLyoqIEB0eXBlIHs/fSAqLyBlKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3J5IG5vdCBhdmFpbGFibGUgLSBiYWlsb3V0XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF91cGRhdGVDb21wRmFjdG9yeSgpIHtcbiAgICAgICAgdGhpcy5fY29tcEZhY3RvcnkgPSB0aGlzLl9yZXNvbHZlQ29tcEZhY3RvcnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9yZXNvbHZlSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1hcElPKGlucHV0cywgdGhpcy5fY29tcEZhY3RvcnkuaW5wdXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfcmVzb2x2ZU91dHB1dHMob3V0cHV0cykge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtYXBJTyhvdXRwdXRzLCB0aGlzLl9jb21wRmFjdG9yeS5vdXRwdXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfcmVzb2x2ZUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtYXBJTyhjaGFuZ2VzLCB0aGlzLl9jb21wRmFjdG9yeS5pbnB1dHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlvXG4gICAgICogQHBhcmFtIHs/fSBtYXBwaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfcmVtYXBJTyhpbywgbWFwcGluZykge1xuICAgICAgICBjb25zdCAvKiogQHR5cGUgez99ICovIG5ld0lPID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGlvKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCAvKiogQHR5cGUgez99ICovIG5ld0tleSA9IHRoaXMuX2ZpbmRQcm9wQnlUcGxJbk1hcHBpbmcoa2V5LCBtYXBwaW5nKSB8fCBrZXk7XG4gICAgICAgICAgICBuZXdJT1tuZXdLZXldID0gaW9ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdJTztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0cGxOYW1lXG4gICAgICogQHBhcmFtIHs/fSBtYXBwaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZmluZFByb3BCeVRwbEluTWFwcGluZyh0cGxOYW1lLCBtYXBwaW5nKSB7XG4gICAgICAgIGZvciAoY29uc3QgLyoqIEB0eXBlIHs/fSAqLyBtYXAgb2YgbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKG1hcC50ZW1wbGF0ZU5hbWUgPT09IHRwbE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwLnByb3BOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbkR5bmFtaWNEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZGNEeW5hbWljSW5wdXRzXSxbbmRjRHluYW1pY091dHB1dHNdLFtuZ0NvbXBvbmVudE91dGxldE5kY0R5bmFtaWNJbnB1dHNdLFtuZ0NvbXBvbmVudE91dGxldE5kY0R5bmFtaWNPdXRwdXRzXScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkR5bmFtaWNEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBLZXlWYWx1ZURpZmZlcnMsIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbQ09NUE9ORU5UX0lOSkVDVE9SLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRPdXRsZXRJbmplY3RvckRpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3sgdHlwZTogSG9zdCB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTtcbkR5bmFtaWNEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgXCJuZGNEeW5hbWljSW5wdXRzXCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICBcIm5nQ29tcG9uZW50T3V0bGV0TmRjRHluYW1pY0lucHV0c1wiOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgXCJuZGNEeW5hbWljT3V0cHV0c1wiOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgXCJuZ0NvbXBvbmVudE91dGxldE5kY0R5bmFtaWNPdXRwdXRzXCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmNsYXNzIER5bmFtaWNNb2R1bGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7Pz19IGNvbXBvbmVudEluamVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzdGF0aWMgd2l0aENvbXBvbmVudHMoY29tcG9uZW50cywgY29tcG9uZW50SW5qZWN0b3IgPSBEeW5hbWljQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogRHluYW1pY01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBDT01QT05FTlRfSU5KRUNUT1IsIHVzZVZhbHVlOiBjb21wb25lbnRJbmplY3RvciB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5EeW5hbWljTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgRHluYW1pY0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgRHluYW1pY0RpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50T3V0bGV0SW5qZWN0b3JEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIER5bmFtaWNBdHRyaWJ1dGVzRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBEeW5hbWljQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBEeW5hbWljRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnRPdXRsZXRJbmplY3RvckRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgRHluYW1pY0F0dHJpYnV0ZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuZXhwb3J0IHsgRHluYW1pY01vZHVsZSwgRHluYW1pY0RpcmVjdGl2ZSwgRHluYW1pY0NvbXBvbmVudCwgRHluYW1pY0F0dHJpYnV0ZXNEaXJlY3RpdmUsIENPTVBPTkVOVF9JTkpFQ1RPUiBhcyDJtWEsIENvbXBvbmVudE91dGxldEluamVjdG9yRGlyZWN0aXZlIGFzIMm1YiB9O1xuIl19