(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core'), require('@angular/forms')) :
  typeof define === 'function' && define.amd ? define('@ctrl/ngx-codemirror', ['@angular/core','exports', '@angular/core', '@angular/forms'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,(global.ctrl = global.ctrl || {}, global.ctrl['ngx-codemirror'] = {}), global.ng.core, global.ng.forms));
}(this, (function (ɵngcc0,exports, core, forms) { 
var _c0 = ["ref"];
'use strict';

  function normalizeLineEndings(str) {
      if (!str) {
          return str;
      }
      return str.replace(/\r\n|\r/g, '\n');
  }
  var CodemirrorComponent = /** @class */ (function () {
      function CodemirrorComponent(_differs, _ngZone) {
          this._differs = _differs;
          this._ngZone = _ngZone;
          /* class applied to the created textarea */
          this.className = '';
          /* name applied to the created textarea */
          this.name = 'codemirror';
          /* autofocus setting applied to the created textarea */
          this.autoFocus = false;
          /* preserve previous scroll position after updating value */
          this.preserveScrollPosition = false;
          /* called when the text cursor is moved */
          this.cursorActivity = new core.EventEmitter();
          /* called when the editor is focused or loses focus */
          this.focusChange = new core.EventEmitter();
          /* called when the editor is scrolled */
          // tslint:disable-next-line:no-output-native
          this.scroll = new core.EventEmitter();
          /* called when file(s) are dropped */
          // tslint:disable-next-line:no-output-native
          this.drop = new core.EventEmitter();
          this.value = '';
          this.disabled = false;
          this.isFocused = false;
          /** Implemented as part of ControlValueAccessor. */
          this.onChange = function (_) { };
          /** Implemented as part of ControlValueAccessor. */
          this.onTouched = function () { };
      }
      Object.defineProperty(CodemirrorComponent.prototype, "options", {
          /**
           * set options for codemirror
           * @link http://codemirror.net/doc/manual.html#config
           */
          set: function (value) {
              this._options = value;
              if (!this._differ && value) {
                  this._differ = this._differs.find(value).create();
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CodemirrorComponent.prototype, "codeMirrorGlobal", {
          get: function () {
              if (this._codeMirror) {
                  return this._codeMirror;
              }
              this._codeMirror = typeof CodeMirror !== 'undefined' ? CodeMirror : require('codemirror');
              return this._codeMirror;
          },
          enumerable: false,
          configurable: true
      });
      CodemirrorComponent.prototype.ngAfterViewInit = function () {
          var _this = this;
          if (!this.ref) {
              return;
          }
          // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
          this._ngZone.runOutsideAngular(function () {
              _this.codeMirror = _this.codeMirrorGlobal.fromTextArea(_this.ref.nativeElement, _this._options);
              _this.codeMirror.on('cursorActivity', function (cm) { return _this._ngZone.run(function () { return _this.cursorActive(cm); }); });
              _this.codeMirror.on('scroll', _this.scrollChanged.bind(_this));
              _this.codeMirror.on('blur', function () { return _this._ngZone.run(function () { return _this.focusChanged(false); }); });
              _this.codeMirror.on('focus', function () { return _this._ngZone.run(function () { return _this.focusChanged(true); }); });
              _this.codeMirror.on('change', function (cm, change) { return _this._ngZone.run(function () { return _this.codemirrorValueChanged(cm, change); }); });
              _this.codeMirror.on('drop', function (cm, e) {
                  _this._ngZone.run(function () { return _this.dropFiles(cm, e); });
              });
              _this.codeMirror.setValue(_this.value);
          });
      };
      CodemirrorComponent.prototype.ngDoCheck = function () {
          var _this = this;
          if (!this._differ) {
              return;
          }
          // check options have not changed
          var changes = this._differ.diff(this._options);
          if (changes) {
              changes.forEachChangedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
              changes.forEachAddedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
              changes.forEachRemovedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
          }
      };
      CodemirrorComponent.prototype.ngOnDestroy = function () {
          // is there a lighter-weight way to remove the cm instance?
          if (this.codeMirror) {
              this.codeMirror.toTextArea();
          }
      };
      CodemirrorComponent.prototype.codemirrorValueChanged = function (cm, change) {
          if (change.origin !== 'setValue') {
              this.value = cm.getValue();
              this.onChange(this.value);
          }
      };
      CodemirrorComponent.prototype.setOptionIfChanged = function (optionName, newValue) {
          if (!this.codeMirror) {
              return;
          }
          // cast to any to handle strictly typed option names
          // could possibly import settings strings available in the future
          this.codeMirror.setOption(optionName, newValue);
      };
      CodemirrorComponent.prototype.focusChanged = function (focused) {
          this.onTouched();
          this.isFocused = focused;
          this.focusChange.emit(focused);
      };
      CodemirrorComponent.prototype.scrollChanged = function (cm) {
          this.scroll.emit(cm.getScrollInfo());
      };
      CodemirrorComponent.prototype.cursorActive = function (cm) {
          this.cursorActivity.emit(cm);
      };
      CodemirrorComponent.prototype.dropFiles = function (cm, e) {
          this.drop.emit([cm, e]);
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.writeValue = function (value) {
          if (value === null || value === undefined) {
              return;
          }
          if (!this.codeMirror) {
              this.value = value;
              return;
          }
          var cur = this.codeMirror.getValue();
          if (value !== cur &&
              normalizeLineEndings(cur) !== normalizeLineEndings(value)) {
              this.value = value;
              if (this.preserveScrollPosition) {
                  var prevScrollPosition = this.codeMirror.getScrollInfo();
                  this.codeMirror.setValue(this.value);
                  this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
              }
              else {
                  this.codeMirror.setValue(this.value);
              }
          }
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.registerOnChange = function (fn) {
          this.onChange = fn;
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.registerOnTouched = function (fn) {
          this.onTouched = fn;
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.setDisabledState = function (isDisabled) {
          this.disabled = isDisabled;
          this.setOptionIfChanged('readOnly', this.disabled);
      };
CodemirrorComponent.ɵfac = function CodemirrorComponent_Factory(t) { return new (t || CodemirrorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CodemirrorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CodemirrorComponent, selectors: [["ngx-codemirror"]], viewQuery: function CodemirrorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ref = _t.first);
    } }, inputs: { className: "className", name: "name", autoFocus: "autoFocus", preserveScrollPosition: "preserveScrollPosition", options: "options" }, outputs: { cursorActivity: "cursorActivity", focusChange: "focusChange", scroll: "scroll", drop: "drop" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: core.forwardRef(function () { return CodemirrorComponent; }),
                multi: true
            },
        ])], decls: 3, vars: 7, consts: [["autocomplete", "off", 3, "name", "autofocus"], ["ref", ""]], template: function CodemirrorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "textarea", 0, 1);
        ɵngcc0.ɵɵtext(2, "    ");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("ngx-codemirror ", ctx.className, "");
        ɵngcc0.ɵɵclassProp("ngx-codemirror--focused", ctx.isFocused);
        ɵngcc0.ɵɵproperty("name", ctx.name)("autofocus", ctx.autoFocus);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CodemirrorComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-codemirror',
                template: "\n    <textarea\n      [name]=\"name\"\n      class=\"ngx-codemirror {{ className }}\"\n      [class.ngx-codemirror--focused]=\"isFocused\"\n      autocomplete=\"off\"\n      [autofocus]=\"autoFocus\"\n      #ref\n    >\n    </textarea>\n  ",
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: core.forwardRef(function () { return CodemirrorComponent; }),
                        multi: true
                    },
                ],
                preserveWhitespaces: false,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.NgZone }]; }, { className: [{
            type: core.Input
        }], name: [{
            type: core.Input
        }], autoFocus: [{
            type: core.Input
        }], preserveScrollPosition: [{
            type: core.Input
        }], cursorActivity: [{
            type: core.Output
        }], focusChange: [{
            type: core.Output
        }], scroll: [{
            type: core.Output
        }], drop: [{
            type: core.Output
        }], options: [{
            type: core.Input
        }], ref: [{
            type: core.ViewChild,
            args: ['ref', { static: true }]
        }] }); })();
      return CodemirrorComponent;
  }());
  CodemirrorComponent.ctorParameters = function () { return [
      { type: core.KeyValueDiffers },
      { type: core.NgZone }
  ]; };
  CodemirrorComponent.propDecorators = {
      className: [{ type: core.Input }],
      name: [{ type: core.Input }],
      autoFocus: [{ type: core.Input }],
      options: [{ type: core.Input }],
      preserveScrollPosition: [{ type: core.Input }],
      cursorActivity: [{ type: core.Output }],
      focusChange: [{ type: core.Output }],
      scroll: [{ type: core.Output }],
      drop: [{ type: core.Output }],
      ref: [{ type: core.ViewChild, args: ['ref', { static: true },] }]
  };

  var CodemirrorModule = /** @class */ (function () {
      function CodemirrorModule() {
      }
CodemirrorModule.ɵfac = function CodemirrorModule_Factory(t) { return new (t || CodemirrorModule)(); };
CodemirrorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CodemirrorModule });
CodemirrorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CodemirrorModule, { declarations: [CodemirrorComponent], exports: [CodemirrorComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CodemirrorModule, [{
        type: core.NgModule,
        args: [{
                exports: [CodemirrorComponent],
                declarations: [CodemirrorComponent]
            }]
    }], function () { return []; }, null); })();
      return CodemirrorModule;
  }());

  /**
   * Generated bundle index. Do not edit.
   */

  exports.CodemirrorComponent = CodemirrorComponent;
  exports.CodemirrorModule = CodemirrorModule;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ctrl-ngx-codemirror.umd.js.map