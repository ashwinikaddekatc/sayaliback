import { RendererStyleFlags2, ViewEncapsulation, InjectionToken, Injectable, NgZone, Inject, NgModule, RendererFactory2, APP_ID, NO_ERRORS_SCHEMA } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventManager, ɵDomSharedStylesHost } from '@angular/platform-browser';

function getArrayDrawingComponents(set) {
    return Array.from(set.values()).filter((c) => c && !!c.draw);
}
class NgCanvas {
    constructor(ngZone, config) {
        this.ngZone = ngZone;
        this.config = config;
        this.componentSet = new Set();
        this.componentsDrawings = [];
        this.element = document.createElement('canvas');
        this.element.style.position = 'absolute';
        this.context = this.element.getContext('2d');
        this._height = this.element.height;
        this._width = this.element.width;
        this.ngZone.runOutsideAngular(() => {
            window.requestAnimationFrame((time) => this.draw(time));
        });
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    set parent(element) {
        this._parentElement = element;
        this.subResizeEvent();
    }
    subResizeEvent() {
        this._parentElement &&
            this.resizeObserver &&
            this.resizeObserver.unobserve(this._parentElement);
        // @ts-ignore
        this.resizeObserver = new ResizeObserver(([entry]) => {
            const dpr = window.devicePixelRatio || 1;
            let width = entry.contentRect.width;
            let height = entry.contentRect.height;
            if (width && height) {
                width = parseInt(width, 10);
                height = parseInt(height, 10);
            }
            let resizeDetected = false;
            if (this._width !== width) {
                this._width = width;
                this.element.width = width * dpr;
                this.element.style.width = width + 'px';
                resizeDetected = true;
            }
            if (this._height !== height) {
                this._height = height;
                this.element.height = height * dpr;
                this.element.style.height = height + 'px';
                resizeDetected = true;
            }
            if (resizeDetected) {
                if (dpr !== 1) {
                    this.context.scale(dpr, dpr);
                }
                this.drawWithoutRequestAnimation();
            }
        });
        this.resizeObserver.observe(this._parentElement);
    }
    resetCanvasSize() {
        const dpr = window.devicePixelRatio || 1;
        this.element.width = this._width * dpr;
        this.element.style.width = this._width + 'px';
        this.element.height = this._height * dpr;
        this.element.style.height = this._height + 'px';
    }
    // tslint:disable-next-line:typedef
    get parent() {
        return this._parent;
    }
    // tslint:disable-next-line:typedef
    destroy() {
        this.resizeObserver &&
            this._parentElement &&
            this.resizeObserver.unobserve(this._parentElement);
        this.componentSet.clear();
        this.componentsDrawings = null;
        this.element && this.element.remove();
    }
    addClass(name) {
        this.element.setAttribute('class', name);
    }
    appendChild(newChild) {
        newChild.onInit && newChild.onInit(this.context);
        this.componentSet.add(newChild);
        this.componentsDrawings = getArrayDrawingComponents(this.componentSet);
        this.drawAll();
    }
    removeChild(oldChild) {
        oldChild.onDestroy && oldChild.onDestroy(this.context);
        this.componentSet.delete(oldChild);
        this.componentsDrawings = getArrayDrawingComponents(this.componentSet);
        this.drawAll();
    }
    insertBefore(newChild, refChild) {
        this.componentSet.add(newChild);
        this.componentsDrawings = getArrayDrawingComponents(this.componentSet);
        this.drawAll();
    }
    recalculateElementsDraw() {
        this.componentsDrawings = getArrayDrawingComponents(this.componentSet);
    }
    removeAttribute(name, namespace) {
        this.element.removeAttribute(name);
    }
    removeClass(name) {
        this.element.classList.remove(name);
    }
    removeStyle(style, flags) {
        // Not supported
    }
    setAttribute(name, value) {
        this.element.setAttribute(name, value);
    }
    setNgAttribute(name, value, namespace) {
        this.element.setAttribute(name, value);
    }
    setNgProperty(name, value) {
        // Not supported
    }
    setStyle(style, value, flags) {
        // Not supported
    }
    setValue(value) {
        // Not supported
    }
    drawAll(clear) {
        this.ngZone.runOutsideAngular(() => {
            this.requestId && window.cancelAnimationFrame(this.requestId);
            this.requestId = window.requestAnimationFrame((time) => {
                this.draw(time, clear);
                this.requestId = null;
            });
        });
    }
    drawWithoutRequestAnimation() {
        this.ngZone.runOutsideAngular(() => {
            this.draw(0, false);
            this.requestId = null;
        });
    }
    // @ts-ignore
    draw(time, clear = true) {
        const context = this.context;
        if (clear) {
            context.clearRect(0, 0, this.width, this.height);
        }
        let needDraw = false;
        const elementsCount = this.componentsDrawings && this.componentsDrawings.length;
        if (elementsCount) {
            for (let i = 0; i < elementsCount; i++) {
                this.componentsDrawings[i].draw(context, time);
                needDraw = needDraw || this.componentsDrawings[i].needDraw;
            }
            if (needDraw) {
                this.requestId && window.cancelAnimationFrame(this.requestId);
                this.requestId = window.requestAnimationFrame((time) => this.draw(time));
            }
        }
    }
}
NgCanvas.nodeName = 'canvas';

const NAMESPACE_URIS = {
    svg: 'http://www.w3.org/2000/svg',
    xhtml: 'http://www.w3.org/1999/xhtml',
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xmlns: 'http://www.w3.org/2000/xmlns/',
};
const COMPONENT_REGEX = /%COMP%/g;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
function shimContentAttribute(componentShortId) {
    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
    // tslint:disable-next-line:prefer-for-of
    for (let i = 0; i < styles.length; i++) {
        let style = styles[i];
        if (Array.isArray(style)) {
            flattenStyles(compId, style, target);
        }
        else {
            style = style.replace(COMPONENT_REGEX, compId);
            target.push(style);
        }
    }
    return target;
}

const ngDevMode = window.ngDevMode;
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;
// tslint:disable-next-line:typedef
function decoratePreventDefault(eventHandler) {
    // `DebugNode.triggerEventHandler` needs to know if the listener was created with
    // decoratePreventDefault or is a listener added outside the Angular context so it can handle the
    // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap
    // the listener (see below).
    return (event) => {
        // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function
        // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node
        // can inspect the listener toString contents for the existence of this special token. Because
        // the token is a string literal, it is ensured to not be modified by compiled code.
        if (event === '__ngUnwrap__') {
            return eventHandler;
        }
        const allowDefaultBehavior = eventHandler(event);
        if (allowDefaultBehavior === false) {
            // TODO(tbosch): move preventDefault into event plugins...
            event.preventDefault();
            event.returnValue = false;
        }
        return undefined;
    };
}
class DefaultDomRenderer2 {
    constructor(eventManager) {
        this.eventManager = eventManager;
        this.data = Object.create(null);
    }
    destroy() { }
    createElement(name, namespace) {
        if (namespace) {
            // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key
            // will result in undefined, so we just return the namespace here.
            return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
        }
        return document.createElement(name);
    }
    createComment(value) {
        return document.createComment(value);
    }
    createText(value) {
        return document.createTextNode(value);
    }
    appendChild(parent, newChild) {
        parent.appendChild(newChild);
    }
    insertBefore(parent, newChild, refChild) {
        if (parent) {
            parent.insertBefore(newChild, refChild);
        }
    }
    removeChild(parent, oldChild) {
        if (parent) {
            parent.removeChild(oldChild);
        }
    }
    selectRootElement(selectorOrNode, preserveContent) {
        const el = typeof selectorOrNode === 'string'
            ? document.querySelector(selectorOrNode)
            : selectorOrNode;
        if (!el) {
            throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
        }
        if (!preserveContent) {
            el.textContent = '';
        }
        return el;
    }
    parentNode(node) {
        return node.parentNode;
    }
    nextSibling(node) {
        return node.nextSibling;
    }
    setAttribute(el, name, value, namespace) {
        if (namespace) {
            name = namespace + ':' + name;
            // TODO(FW-811): Ivy may cause issues here because it's passing around
            // full URIs for namespaces, therefore this lookup will fail.
            const namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.setAttributeNS(namespaceUri, name, value);
            }
            else {
                el.setAttribute(name, value);
            }
        }
        else {
            el.setAttribute(name, value);
        }
    }
    removeAttribute(el, name, namespace) {
        if (namespace) {
            // TODO(FW-811): Ivy may cause issues here because it's passing around
            // full URIs for namespaces, therefore this lookup will fail.
            const namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.removeAttributeNS(namespaceUri, name);
            }
            else {
                // TODO(FW-811): Since ivy is passing around full URIs for namespaces
                // this could result in properties like `http://www.w3.org/2000/svg:cx="123"`,
                // which is wrong.
                el.removeAttribute(`${namespace}:${name}`);
            }
        }
        else {
            el.removeAttribute(name);
        }
    }
    addClass(el, name) {
        el.classList.add(name);
    }
    removeClass(el, name) {
        el.classList.remove(name);
    }
    setStyle(el, style, value, flags) {
        // tslint:disable-next-line:no-bitwise
        if (flags &
            (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
            el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');
        }
        else {
            el.style[style] = value;
        }
    }
    removeStyle(el, style, flags) {
        // tslint:disable-next-line:no-bitwise
        if (flags & RendererStyleFlags2.DashCase) {
            el.style.removeProperty(style);
        }
        else {
            // IE requires '' instead of null
            // see https://github.com/angular/angular/issues/7916
            el.style[style] = '';
        }
    }
    setProperty(el, name, value) {
        // tslint:disable-next-line:no-unused-expression
        NG_DEV_MODE && checkNoSyntheticProp(name, 'property');
        el[name] = value;
    }
    setValue(node, value) {
        node.nodeValue = value;
    }
    listen(target, event, callback) {
        // tslint:disable-next-line:no-unused-expression
        NG_DEV_MODE && checkNoSyntheticProp(event, 'listener');
        if (typeof target === 'string') {
            return (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)));
        }
        return (this.eventManager.addEventListener(target, event, decoratePreventDefault(callback)));
    }
}
const ɵ0 = () => '@'.charCodeAt(0);
const AT_CHARCODE = (ɵ0)();
// tslint:disable-next-line:typedef
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`);
    }
}
class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, component, appId) {
        super(eventManager);
        this.component = component;
        const styles = flattenStyles(appId + '-' + component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        this.contentAttr = shimContentAttribute(appId + '-' + component.id);
        this.hostAttr = shimHostAttribute(appId + '-' + component.id);
    }
    // tslint:disable-next-line:typedef
    applyToHost(element) {
        super.setAttribute(element, this.hostAttr, '');
    }
    createElement(parent, name) {
        const el = super.createElement(parent, name);
        super.setAttribute(el, this.contentAttr, '');
        return el;
    }
}
class ShadowDomRenderer extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, hostEl, component) {
        super(eventManager);
        this.sharedStylesHost = sharedStylesHost;
        this.hostEl = hostEl;
        this.component = component;
        if (component.encapsulation === ViewEncapsulation.ShadowDom) {
            this.shadowRoot = hostEl.attachShadow({ mode: 'open' });
        }
        else {
            this.shadowRoot = hostEl.createShadowRoot();
        }
        this.sharedStylesHost.addHost(this.shadowRoot);
        const styles = flattenStyles(component.id, component.styles, []);
        for (let i = 0; i < styles.length; i++) {
            const styleEl = document.createElement('style');
            styleEl.textContent = styles[i];
            this.shadowRoot.appendChild(styleEl);
        }
    }
    nodeOrShadowRoot(node) {
        return node === this.hostEl ? this.shadowRoot : node;
    }
    destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot);
    }
    appendChild(parent, newChild) {
        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
    }
    insertBefore(parent, newChild, refChild) {
        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
    }
    removeChild(parent, oldChild) {
        return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
    }
    parentNode(node) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
    }
}

function getMetadataArgsStorage() {
    if (!window.canvasRendererMetadataArgsStorage) {
        window.canvasRendererMetadataArgsStorage = new MetadataArgsStorage();
    }
    return window.canvasRendererMetadataArgsStorage;
}
class MetadataArgsStorage {
    constructor() {
        this.elements = new Map();
    }
}

const DefaultCanvasRenderConfig = {
    property: true,
};
const CanvasRenderConfig = new InjectionToken('CanvasRenderConfig');

class CanvasDomRendererFactory {
    constructor(eventManager, sharedStylesHost, appId, ngZone, canvasConfig) {
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.appId = appId;
        this.ngZone = ngZone;
        this.canvasConfig = canvasConfig;
        this.rendererByCompId = new Map();
        this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    end() { }
    createRenderer(element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        // @ts-ignore
        if (type['type'] && type['type'].isCanvasComponent) {
            let renderer = this.rendererByCompId.get(type.id);
            if (!renderer) {
                renderer = new CanvasRenderer(this.eventManager, this.sharedStylesHost, type, this.appId, this.ngZone, this.canvasConfig);
                this.rendererByCompId.set(type.id, renderer);
            }
            renderer.applyToHost(element);
            return renderer;
        }
        switch (type.encapsulation) {
            case ViewEncapsulation.Emulated: {
                let renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
                    this.rendererByCompId.set(type.id, renderer);
                }
                renderer.applyToHost(element);
                return renderer;
            }
            case ViewEncapsulation.ShadowDom:
                return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    const styles = flattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    }
}
CanvasDomRendererFactory.decorators = [
    { type: Injectable }
];
CanvasDomRendererFactory.ctorParameters = () => [
    { type: EventManager },
    { type: ɵDomSharedStylesHost },
    { type: String },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [CanvasRenderConfig,] }] }
];
class CanvasRenderer {
    constructor(eventManager, sharedStylesHost, component, appId, ngZone, config) {
        this.component = component;
        this.ngZone = ngZone;
        this.config = config;
        this.canvasElements = getMetadataArgsStorage().elements;
        const styles = flattenStyles(appId + '-' + component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        this.contentAttr = shimContentAttribute(appId + '-' + component.id);
        this.hostAttr = shimHostAttribute(appId + '-' + component.id);
    }
    // tslint:disable-next-line:typedef
    applyToHost(element) {
        this.setAttribute(element, this.hostAttr, '');
    }
    createElement(name, namespace) {
        const Component = this.canvasElements.get(name);
        if (Component) {
            return new Component();
        }
        else if (name === 'canvas') {
            const canvas = new NgCanvas(this.ngZone, this.config);
            canvas.element.setAttribute(this.contentAttr, '');
            return canvas;
        }
        else {
            let element;
            if (namespace) {
                // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key
                // will result in undefined, so we just return the namespace here.
                element = document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
            }
            else {
                element = document.createElement(name);
            }
            this.setAttribute(element, this.contentAttr, '');
            return element;
        }
    }
    createText(value) {
        return document.createTextNode(value);
    }
    selectRootElement(selectorOrNode, preserveContent) {
        const el = typeof selectorOrNode === 'string'
            ? document.querySelector(selectorOrNode)
            : selectorOrNode;
        if (!el) {
            throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
        }
        if (!preserveContent) {
            el.textContent = '';
        }
        return el;
    }
    addClass(el, name) {
        if (el.classList) {
            el.classList.add(name);
        }
        else {
            el.addClass(name);
        }
    }
    removeClass(el, name) {
        if (el.classList) {
            el.classList.add(name);
        }
        else {
            el.removeClass(name);
        }
    }
    appendChild(parent, newChild) {
        // parent.appendChild(newChild);
        if (!newChild) {
            return;
        }
        newChild.parent = parent;
        if (newChild instanceof NgCanvas) {
            parent.appendChild(newChild.element);
        }
        else {
            parent.appendChild(newChild);
        }
    }
    removeChild(parent, oldChild) {
        // tslint:disable-next-line:no-unused-expression
        oldChild.destroy && oldChild.destroy();
        if (parent) {
            parent.removeChild(oldChild);
        }
        if (oldChild && oldChild.parent instanceof NgCanvas) {
            oldChild.parent.removeChild(oldChild);
        }
    }
    createComment(value) {
        return document.createComment(value);
    }
    destroy() { }
    insertBefore(parent, newChild, refChild) {
        if (parent && parent.insertBefore) {
            newChild.parent = parent;
            if (newChild instanceof NgCanvas) {
                parent.insertBefore(newChild.element, refChild);
            }
            else {
                parent.insertBefore(newChild, refChild);
            }
        }
    }
    listen(target, eventName, callback) {
        const callbackFunc = (e) => callback.call(target, e);
        if (target instanceof NgCanvas) {
            target = target.element;
        }
        target.addEventListener(eventName, callbackFunc);
        return () => target.removeEventListener(eventName, callbackFunc);
    }
    // tslint:disable-next-line:typedef
    nextSibling(node) {
        return {
            previous: node,
            next: node.nextSibling,
        };
    }
    parentNode(node) {
        return node.parent ? node.parent : node;
    }
    removeAttribute(el, name, namespace) {
        if (namespace) {
            // TODO(FW-811): Ivy may cause issues here because it's passing around
            // full URIs for namespaces, therefore this lookup will fail.
            const namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.removeAttributeNS(namespaceUri, name);
            }
            else {
                // TODO(FW-811): Since ivy is passing around full URIs for namespaces
                // this could result in properties like `http://www.w3.org/2000/svg:cx="123"`,
                // which is wrong.
                el.removeAttribute(`${namespace}:${name}`);
            }
        }
        else {
            el.removeAttribute(name);
        }
    }
    removeStyle(el, style, flags) {
        el.removeStyle(style, flags);
    }
    setAttribute(el, name, value, namespace) {
        if (namespace) {
            name = namespace + ':' + name;
            // TODO(FW-811): Ivy may cause issues here because it's passing around
            // full URIs for namespaces, therefore this lookup will fail.
            const namespaceUri = NAMESPACE_URIS[namespace];
            if (namespaceUri) {
                el.setAttributeNS(namespaceUri, name, value);
            }
            else {
                el.setAttribute(name, value);
            }
        }
        else {
            el.setAttribute(name, value);
        }
    }
    setProperty(el, name, value) {
        el.setNgProperty(name, value);
    }
    setStyle(el, style, value, flags) {
        if (el.style) {
            // tslint:disable-next-line:no-bitwise
            if (flags & RendererStyleFlags2.DashCase) {
                el.style.setProperty(
                // tslint:disable-next-line:no-bitwise
                style, value, flags & RendererStyleFlags2.Important ? 'important' : '');
            }
            else {
                el.style[style] = value;
            }
        }
        else {
            el.setStyle(style, value, flags);
        }
    }
    setValue(node, value) {
        if (node.setValue) {
            node.setValue(value);
        }
        else {
            node.nodeValue = value;
        }
    }
}

class CanvasDomModule {
    // tslint:disable-next-line:typedef
    static forRoot(elements) {
        return {
            ngModule: CanvasDomModule,
        };
    }
}
CanvasDomModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [
                    {
                        provide: RendererFactory2,
                        useClass: CanvasDomRendererFactory,
                        deps: [EventManager, ɵDomSharedStylesHost, APP_ID, NgZone],
                    },
                ],
                schemas: [NO_ERRORS_SCHEMA],
            },] }
];

// tslint:disable-next-line:typedef
function CanvasComponent(target) {
    target.isCanvasComponent = true;
}

// tslint:disable-next-line:typedef
// tslint:disable-next-line:typedef
function CanvasElement(config) {
    // tslint:disable-next-line:only-arrow-functions typedef
    return function (target) {
        getMetadataArgsStorage().elements.set(config.selector, target);
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { CanvasComponent, CanvasDomModule, CanvasDomRendererFactory, CanvasElement, CanvasRenderer, MetadataArgsStorage, NgCanvas, getMetadataArgsStorage, CanvasRenderConfig as ɵb };
//# sourceMappingURL=angular-canvas.js.map
