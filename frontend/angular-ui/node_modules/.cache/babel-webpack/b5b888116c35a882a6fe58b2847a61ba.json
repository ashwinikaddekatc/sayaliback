{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @packageDocumentation\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { removeNodes } from './dom.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { marker, Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js'; // Get a key to lookup in `templateCaches`.\n\nvar getTemplateCacheKey = function getTemplateCacheKey(type, scopeName) {\n  return \"\".concat(type, \"--\").concat(scopeName);\n};\n\nvar compatibleShadyCSSVersion = true;\n\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(\"Incompatible ShadyCSS version detected. \" + \"Please update to at least @webcomponents/webcomponentsjs@2.0.2 and \" + \"@webcomponents/shadycss@1.3.1.\");\n  compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\n\n\nexport var shadyTemplateFactory = function shadyTemplateFactory(scopeName) {\n  return function (result) {\n    var cacheKey = getTemplateCacheKey(result.type, scopeName);\n    var templateCache = templateCaches.get(cacheKey);\n\n    if (templateCache === undefined) {\n      templateCache = {\n        stringsArray: new WeakMap(),\n        keyString: new Map()\n      };\n      templateCaches.set(cacheKey, templateCache);\n    }\n\n    var template = templateCache.stringsArray.get(result.strings);\n\n    if (template !== undefined) {\n      return template;\n    }\n\n    var key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n\n    if (template === undefined) {\n      var element = result.getTemplateElement();\n\n      if (compatibleShadyCSSVersion) {\n        window.ShadyCSS.prepareTemplateDom(element, scopeName);\n      }\n\n      template = new Template(result, element);\n      templateCache.keyString.set(key, template);\n    }\n\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n  };\n};\nvar TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\n\nvar removeStylesFromLitTemplates = function removeStylesFromLitTemplates(scopeName) {\n  TEMPLATE_TYPES.forEach(function (type) {\n    var templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n\n    if (templates !== undefined) {\n      templates.keyString.forEach(function (template) {\n        var content = template.element.content; // IE 11 doesn't support the iterable param Set constructor\n\n        var styles = new Set();\n        Array.from(content.querySelectorAll('style')).forEach(function (s) {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\n\nvar shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\n\nvar prepareTemplateStyles = function prepareTemplateStyles(scopeName, renderedDOM, template) {\n  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that\n  // Template's underlying template element. Otherwise, we create one here\n  // to give to ShadyCSS, which still requires one while scoping.\n\n  var templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.\n\n  var styles = renderedDOM.querySelectorAll('style');\n  var length = styles.length; // If there are no styles, skip unnecessary work\n\n  if (length === 0) {\n    // Ensure prepareTemplateStyles is called to support adding\n    // styles via `prepareAdoptedCssText` since that requires that\n    // `prepareTemplateStyles` is called.\n    //\n    // ShadyCSS will only update styles containing @apply in the template\n    // given to `prepareTemplateStyles`. If no lit Template was given,\n    // ShadyCSS will not be able to update uses of @apply in any relevant\n    // template. However, this is not a problem because we only create the\n    // template for the purpose of supporting `prepareAdoptedCssText`,\n    // which doesn't support @apply at all.\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    return;\n  }\n\n  var condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS\n  // manipulations will not prevent us from being able to fix up template\n  // part indices.\n  // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n  // currently does this anyway. When it does not, this should be changed.\n\n  for (var i = 0; i < length; i++) {\n    var _style = styles[i];\n\n    _style.parentNode.removeChild(_style);\n\n    condensedStyle.textContent += _style.textContent;\n  } // Remove styles from nested templates in this scope.\n\n\n  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the \"root\" template passed in as\n  // `template`.\n\n  var content = templateElement.content;\n\n  if (!!template) {\n    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n  } else {\n    content.insertBefore(condensedStyle, content.firstChild);\n  } // Note, it's important that ShadyCSS gets the template that `lit-html`\n  // will actually render so that it can update the style inside when\n  // needed (e.g. @apply native Shadow DOM case).\n\n\n  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n  var style = content.querySelector('style');\n\n  if (window.ShadyCSS.nativeShadow && style !== null) {\n    // When in native Shadow DOM, ensure the style created by ShadyCSS is\n    // included in initially rendered output (`renderedDOM`).\n    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n  } else if (!!template) {\n    // When no style is left in the template, parts will be broken as a\n    // result. To fix this, we put back the style node ShadyCSS removed\n    // and then tell lit to remove that node from the template.\n    // There can be no style in the template in 2 cases (1) when Shady DOM\n    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n    // is in use ShadyCSS removes the style if it contains no content.\n    // NOTE, ShadyCSS creates its own style so we can safely add/remove\n    // `condensedStyle` here.\n    content.insertBefore(condensedStyle, content.firstChild);\n    var removes = new Set();\n    removes.add(condensedStyle);\n    removeNodesFromTemplate(template, removes);\n  }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\n\n\nexport var render = function render(result, container, options) {\n  if (!options || typeof options !== 'object' || !options.scopeName) {\n    throw new Error('The `scopeName` option is required.');\n  }\n\n  var scopeName = options.scopeName;\n  var hasRendered = parts.has(container);\n  var needsScoping = compatibleShadyCSSVersion && container.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  && !!container.host; // Handle first render to a scope specially...\n\n  var firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single\n  // fragment that is reused since nested renders can occur synchronously.\n\n  var renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n  litRender(result, renderContainer, Object.assign({\n    templateFactory: shadyTemplateFactory(scopeName)\n  }, options)); // When performing first scope render,\n  // (1) We've rendered into a fragment so that there's a chance to\n  // `prepareTemplateStyles` before sub-elements hit the DOM\n  // (which might cause them to render based on a common pattern of\n  // rendering in a custom element's `connectedCallback`);\n  // (2) Scope the template with ShadyCSS one time only for this scope.\n  // (3) Render the fragment into the container and make sure the\n  // container knows its `part` is the one we just rendered. This ensures\n  // DOM will be re-used on subsequent renders.\n\n  if (firstScopeRender) {\n    var part = parts.get(renderContainer);\n    parts.delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n    // that should apply to `renderContainer` even if the rendered value is\n    // not a TemplateInstance. However, it will only insert scoped styles\n    // into the document if `prepareTemplateStyles` has already been called\n    // for the given scope name.\n\n    var template = part.value instanceof TemplateInstance ? part.value.template : undefined;\n    prepareTemplateStyles(scopeName, renderContainer, template);\n    removeNodes(container, container.firstChild);\n    container.appendChild(renderContainer);\n    parts.set(container, part);\n  } // After elements have hit the DOM, update styling if this is the\n  // initial render to this container.\n  // This is needed whenever dynamic changes are made so it would be\n  // safest to do every render; however, this would regress performance\n  // so we leave it up to the user to call `ShadyCSS.styleElement`\n  // for dynamic changes.\n\n\n  if (!hasRendered && needsScoping) {\n    window.ShadyCSS.styleElement(container.host);\n  }\n}; //# sourceMappingURL=shady-render.js.map","map":{"version":3,"sources":["C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/lit-html/lib/shady-render.js"],"names":["removeNodes","insertNodeIntoTemplate","removeNodesFromTemplate","parts","render","litRender","templateCaches","TemplateInstance","marker","Template","html","svg","TemplateResult","getTemplateCacheKey","type","scopeName","compatibleShadyCSSVersion","window","ShadyCSS","prepareTemplateDom","console","warn","shadyTemplateFactory","result","cacheKey","templateCache","get","undefined","stringsArray","WeakMap","keyString","Map","set","template","strings","key","join","element","getTemplateElement","TEMPLATE_TYPES","removeStylesFromLitTemplates","forEach","templates","content","styles","Set","Array","from","querySelectorAll","s","add","shadyRenderSet","prepareTemplateStyles","renderedDOM","templateElement","document","createElement","length","condensedStyle","i","style","parentNode","removeChild","textContent","firstChild","insertBefore","querySelector","nativeShadow","cloneNode","removes","container","options","Error","hasRendered","has","needsScoping","nodeType","host","firstScopeRender","renderContainer","createDocumentFragment","Object","assign","templateFactory","part","delete","value","appendChild","styleElement"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @packageDocumentation\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { removeNodes } from './dom.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { marker, Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(`Incompatible ShadyCSS version detected. ` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nexport const shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    const key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n    }\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.keyString.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn't support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll('style')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n    shadyRenderSet.add(scopeName);\n    // If `renderedDOM` is stamped from a Template, then we need to edit that\n    // Template's underlying template element. Otherwise, we create one here\n    // to give to ShadyCSS, which still requires one while scoping.\n    const templateElement = !!template ? template.element : document.createElement('template');\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll('style');\n    const { length } = styles;\n    // If there are no styles, skip unnecessary work\n    if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn't support @apply at all.\n        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n        return;\n    }\n    const condensedStyle = document.createElement('style');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the \"root\" template passed in as\n    // `template`.\n    const content = templateElement.content;\n    if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n    }\n    else {\n        content.insertBefore(condensedStyle, content.firstChild);\n    }\n    // Note, it's important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    const style = content.querySelector('style');\n    if (window.ShadyCSS.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nexport const render = (result, container, options) => {\n    if (!options || typeof options !== 'object' || !options.scopeName) {\n        throw new Error('The `scopeName` option is required.');\n    }\n    const scopeName = options.scopeName;\n    const hasRendered = parts.has(container);\n    const needsScoping = compatibleShadyCSSVersion &&\n        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n        !!container.host;\n    // Handle first render to a scope specially...\n    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n    // On first scope render, render into a fragment; this cannot be a single\n    // fragment that is reused since nested renders can occur synchronously.\n    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n    litRender(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When performing first scope render,\n    // (1) We've rendered into a fragment so that there's a chance to\n    // `prepareTemplateStyles` before sub-elements hit the DOM\n    // (which might cause them to render based on a common pattern of\n    // rendering in a custom element's `connectedCallback`);\n    // (2) Scope the template with ShadyCSS one time only for this scope.\n    // (3) Render the fragment into the container and make sure the\n    // container knows its `part` is the one we just rendered. This ensures\n    // DOM will be re-used on subsequent renders.\n    if (firstScopeRender) {\n        const part = parts.get(renderContainer);\n        parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(scopeName, renderContainer, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        parts.set(container, part);\n    }\n    // After elements have hit the DOM, update styling if this is the\n    // initial render to this container.\n    // This is needed whenever dynamic changes are made so it would be\n    // safest to do every render; however, this would regress performance\n    // so we leave it up to the user to call `ShadyCSS.styleElement`\n    // for dynamic changes.\n    if (!hasRendered && needsScoping) {\n        window.ShadyCSS.styleElement(container.host);\n    }\n};\n//# sourceMappingURL=shady-render.js.map"]},"metadata":{},"sourceType":"module"}