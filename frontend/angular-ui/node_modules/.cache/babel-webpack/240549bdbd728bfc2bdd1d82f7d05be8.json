{"ast":null,"code":"import _get from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport var isPrimitive = function isPrimitive(value) {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\nexport var isIterable = function isIterable(value) {\n  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  !!(value && value[Symbol.iterator]);\n};\n/**\r\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\r\n * single attribute. The value is only set once even if there are multiple parts\r\n * for an attribute.\r\n */\n\nexport var AttributeCommitter = /*#__PURE__*/function () {\n  function AttributeCommitter(element, name, strings) {\n    _classCallCheck(this, AttributeCommitter);\n\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n\n    for (var i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  /**\r\n   * Creates a single part. Override this to create a differnt type of part.\r\n   */\n\n\n  _createClass(AttributeCommitter, [{\n    key: \"_createPart\",\n    value: function _createPart() {\n      return new AttributePart(this);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      var strings = this.strings;\n      var l = strings.length - 1;\n      var parts = this.parts; // If we're assigning an attribute via syntax like:\n      //    attr=\"${foo}\"  or  attr=${foo}\n      // but not\n      //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n      // then we don't want to coerce the attribute value into one long\n      // string. Instead we want to just return the value itself directly,\n      // so that sanitizeDOMValue can get the actual value rather than\n      // String(value)\n      // The exception is if v is an array, in which case we do want to smash\n      // it together into a string without calling String() on the array.\n      //\n      // This also allows trusted values (when using TrustedTypes) being\n      // assigned to DOM sinks without being stringified in the process.\n\n      if (l === 1 && strings[0] === '' && strings[1] === '') {\n        var v = parts[0].value;\n\n        if (typeof v === 'symbol') {\n          return String(v);\n        }\n\n        if (typeof v === 'string' || !isIterable(v)) {\n          return v;\n        }\n      }\n\n      var text = '';\n\n      for (var i = 0; i < l; i++) {\n        text += strings[i];\n        var part = parts[i];\n\n        if (part !== undefined) {\n          var _v = part.value;\n\n          if (isPrimitive(_v) || !isIterable(_v)) {\n            text += typeof _v === 'string' ? _v : String(_v);\n          } else {\n            var _iterator = _createForOfIteratorHelper(_v),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var t = _step.value;\n                text += typeof t === 'string' ? t : String(t);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n        }\n      }\n\n      text += strings[l];\n      return text;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.dirty) {\n        this.dirty = false;\n        this.element.setAttribute(this.name, this._getValue());\n      }\n    }\n  }]);\n\n  return AttributeCommitter;\n}();\n/**\r\n * A Part that controls all or part of an attribute value.\r\n */\n\nexport var AttributePart = /*#__PURE__*/function () {\n  function AttributePart(committer) {\n    _classCallCheck(this, AttributePart);\n\n    this.value = undefined;\n    this.committer = committer;\n  }\n\n  _createClass(AttributePart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n        this.value = value; // If the value is a not a directive, dirty the committer so that it'll\n        // call setAttribute. If the value is a directive, it'll dirty the\n        // committer if it calls setValue().\n\n        if (!isDirective(value)) {\n          this.committer.dirty = true;\n        }\n      }\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.value)) {\n        var directive = this.value;\n        this.value = noChange;\n        directive(this);\n      }\n\n      if (this.value === noChange) {\n        return;\n      }\n\n      this.committer.commit();\n    }\n  }]);\n\n  return AttributePart;\n}();\n/**\r\n * A Part that controls a location within a Node tree. Like a Range, NodePart\r\n * has start and end locations and can set and update the Nodes between those\r\n * locations.\r\n *\r\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\r\n * as well as arrays and iterables of those types.\r\n */\n\nexport var NodePart = /*#__PURE__*/function () {\n  function NodePart(options) {\n    _classCallCheck(this, NodePart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\r\n   * Appends this part into a container.\r\n   *\r\n   * This part must be empty, as its contents are not automatically moved.\r\n   */\n\n\n  _createClass(NodePart, [{\n    key: \"appendInto\",\n    value: function appendInto(container) {\n      this.startNode = container.appendChild(createMarker());\n      this.endNode = container.appendChild(createMarker());\n    }\n    /**\r\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\r\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\r\n     * such as those that appear in a literal section of a template.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\n\n  }, {\n    key: \"insertAfterNode\",\n    value: function insertAfterNode(ref) {\n      this.startNode = ref;\n      this.endNode = ref.nextSibling;\n    }\n    /**\r\n     * Appends this part into a parent part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\n\n  }, {\n    key: \"appendIntoPart\",\n    value: function appendIntoPart(part) {\n      part.__insert(this.startNode = createMarker());\n\n      part.__insert(this.endNode = createMarker());\n    }\n    /**\r\n     * Inserts this part after the `ref` part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\n\n  }, {\n    key: \"insertAfterPart\",\n    value: function insertAfterPart(ref) {\n      ref.__insert(this.startNode = createMarker());\n\n      this.endNode = ref.endNode;\n      ref.endNode = this.startNode;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.startNode.parentNode === null) {\n        return;\n      }\n\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      var value = this.__pendingValue;\n\n      if (value === noChange) {\n        return;\n      }\n\n      if (isPrimitive(value)) {\n        if (value !== this.value) {\n          this.__commitText(value);\n        }\n      } else if (value instanceof TemplateResult) {\n        this.__commitTemplateResult(value);\n      } else if (value instanceof Node) {\n        this.__commitNode(value);\n      } else if (isIterable(value)) {\n        this.__commitIterable(value);\n      } else if (value === nothing) {\n        this.value = nothing;\n        this.clear();\n      } else {\n        // Fallback, will render the string representation\n        this.__commitText(value);\n      }\n    }\n  }, {\n    key: \"__insert\",\n    value: function __insert(node) {\n      this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n  }, {\n    key: \"__commitNode\",\n    value: function __commitNode(value) {\n      if (this.value === value) {\n        return;\n      }\n\n      this.clear();\n\n      this.__insert(value);\n\n      this.value = value;\n    }\n  }, {\n    key: \"__commitText\",\n    value: function __commitText(value) {\n      var node = this.startNode.nextSibling;\n      value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case\n      // it can't be implicitly converted - i.e. it's a symbol.\n\n      var valueAsString = typeof value === 'string' ? value : String(value);\n\n      if (node === this.endNode.previousSibling && node.nodeType === 3\n      /* Node.TEXT_NODE */\n      ) {\n          // If we only have a single text node between the markers, we can just\n          // set its value, rather than replacing it.\n          // TODO(justinfagnani): Can we just check if this.value is primitive?\n          node.data = valueAsString;\n        } else {\n        this.__commitNode(document.createTextNode(valueAsString));\n      }\n\n      this.value = value;\n    }\n  }, {\n    key: \"__commitTemplateResult\",\n    value: function __commitTemplateResult(value) {\n      var template = this.options.templateFactory(value);\n\n      if (this.value instanceof TemplateInstance && this.value.template === template) {\n        this.value.update(value.values);\n      } else {\n        // Make sure we propagate the template processor from the TemplateResult\n        // so that we use its syntax extension, etc. The template factory comes\n        // from the render function options so that it can control template\n        // caching and preprocessing.\n        var instance = new TemplateInstance(template, value.processor, this.options);\n\n        var fragment = instance._clone();\n\n        instance.update(value.values);\n\n        this.__commitNode(fragment);\n\n        this.value = instance;\n      }\n    }\n  }, {\n    key: \"__commitIterable\",\n    value: function __commitIterable(value) {\n      // For an Iterable, we create a new InstancePart per item, then set its\n      // value to the item. This is a little bit of overhead for every item in\n      // an Iterable, but it lets us recurse easily and efficiently update Arrays\n      // of TemplateResults that will be commonly returned from expressions like:\n      // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n      // If _value is an array, then the previous render was of an\n      // iterable and _value will contain the NodeParts from the previous\n      // render. If _value is not an array, clear this part and make a new\n      // array for NodeParts.\n      if (!Array.isArray(this.value)) {\n        this.value = [];\n        this.clear();\n      } // Lets us keep track of how many items we stamped so we can clear leftover\n      // items from a previous render\n\n\n      var itemParts = this.value;\n      var partIndex = 0;\n      var itemPart;\n\n      var _iterator2 = _createForOfIteratorHelper(value),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          // Try to reuse an existing part\n          itemPart = itemParts[partIndex]; // If no existing part, create a new one\n\n          if (itemPart === undefined) {\n            itemPart = new NodePart(this.options);\n            itemParts.push(itemPart);\n\n            if (partIndex === 0) {\n              itemPart.appendIntoPart(this);\n            } else {\n              itemPart.insertAfterPart(itemParts[partIndex - 1]);\n            }\n          }\n\n          itemPart.setValue(item);\n          itemPart.commit();\n          partIndex++;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (partIndex < itemParts.length) {\n        // Truncate the parts array so _value reflects the current state\n        itemParts.length = partIndex;\n        this.clear(itemPart && itemPart.endNode);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;\n      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n  }]);\n\n  return NodePart;\n}();\n/**\r\n * Implements a boolean attribute, roughly as defined in the HTML\r\n * specification.\r\n *\r\n * If the value is truthy, then the attribute is present with a value of\r\n * ''. If the value is falsey, the attribute is removed.\r\n */\n\nexport var BooleanAttributePart = /*#__PURE__*/function () {\n  function BooleanAttributePart(element, name, strings) {\n    _classCallCheck(this, BooleanAttributePart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error('Boolean attributes can only contain a single expression');\n    }\n\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  _createClass(BooleanAttributePart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      if (this.__pendingValue === noChange) {\n        return;\n      }\n\n      var value = !!this.__pendingValue;\n\n      if (this.value !== value) {\n        if (value) {\n          this.element.setAttribute(this.name, '');\n        } else {\n          this.element.removeAttribute(this.name);\n        }\n\n        this.value = value;\n      }\n\n      this.__pendingValue = noChange;\n    }\n  }]);\n\n  return BooleanAttributePart;\n}();\n/**\r\n * Sets attribute values for PropertyParts, so that the value is only set once\r\n * even if there are multiple parts for a property.\r\n *\r\n * If an expression controls the whole property value, then the value is simply\r\n * assigned to the property under control. If there are string literals or\r\n * multiple expressions, then the strings are expressions are interpolated into\r\n * a string first.\r\n */\n\nexport var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {\n  _inherits(PropertyCommitter, _AttributeCommitter);\n\n  var _super = _createSuper(PropertyCommitter);\n\n  function PropertyCommitter(element, name, strings) {\n    var _this;\n\n    _classCallCheck(this, PropertyCommitter);\n\n    _this = _super.call(this, element, name, strings);\n    _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';\n    return _this;\n  }\n\n  _createClass(PropertyCommitter, [{\n    key: \"_createPart\",\n    value: function _createPart() {\n      return new PropertyPart(this);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      if (this.single) {\n        return this.parts[0].value;\n      }\n\n      return _get(_getPrototypeOf(PropertyCommitter.prototype), \"_getValue\", this).call(this);\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.dirty) {\n        this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        this.element[this.name] = this._getValue();\n      }\n    }\n  }]);\n\n  return PropertyCommitter;\n}(AttributeCommitter);\nexport var PropertyPart = /*#__PURE__*/function (_AttributePart) {\n  _inherits(PropertyPart, _AttributePart);\n\n  var _super2 = _createSuper(PropertyPart);\n\n  function PropertyPart() {\n    _classCallCheck(this, PropertyPart);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return PropertyPart;\n}(AttributePart); // Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\n\nvar eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n\n(function () {\n  try {\n    var options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.removeEventListener('test', options, options);\n  } catch (_e) {// event options not supported\n  }\n})();\n\nexport var EventPart = /*#__PURE__*/function () {\n  function EventPart(element, eventName, eventContext) {\n    var _this2 = this;\n\n    _classCallCheck(this, EventPart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n\n    this.__boundHandleEvent = function (e) {\n      return _this2.handleEvent(e);\n    };\n  }\n\n  _createClass(EventPart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      if (this.__pendingValue === noChange) {\n        return;\n      }\n\n      var newListener = this.__pendingValue;\n      var oldListener = this.value;\n      var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);\n      var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n\n      if (shouldRemoveListener) {\n        this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n      }\n\n      if (shouldAddListener) {\n        this.__options = getOptions(newListener);\n        this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n      }\n\n      this.value = newListener;\n      this.__pendingValue = noChange;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      if (typeof this.value === 'function') {\n        this.value.call(this.eventContext || this.element, event);\n      } else {\n        this.value.handleEvent(event);\n      }\n    }\n  }]);\n\n  return EventPart;\n}(); // We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\n\nvar getOptions = function getOptions(o) {\n  return o && (eventOptionsSupported ? {\n    capture: o.capture,\n    passive: o.passive,\n    once: o.once\n  } : o.capture);\n}; //# sourceMappingURL=parts.js.map","map":{"version":3,"sources":["C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/lit-html/lib/parts.js"],"names":["isDirective","removeNodes","noChange","nothing","TemplateInstance","TemplateResult","createMarker","isPrimitive","value","isIterable","Array","isArray","Symbol","iterator","AttributeCommitter","element","name","strings","dirty","parts","i","length","_createPart","AttributePart","l","v","String","text","part","undefined","t","setAttribute","_getValue","committer","directive","commit","NodePart","options","__pendingValue","container","startNode","appendChild","endNode","ref","nextSibling","__insert","parentNode","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","node","insertBefore","valueAsString","previousSibling","nodeType","data","document","createTextNode","template","templateFactory","update","values","instance","processor","fragment","_clone","itemParts","partIndex","itemPart","item","push","appendIntoPart","insertAfterPart","setValue","BooleanAttributePart","Error","removeAttribute","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","window","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","__boundHandleEvent","e","handleEvent","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","getOptions","event","call","o"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAT,QAA4B,gBAA5B;AACA,SAASC,WAAT,QAA4B,UAA5B;AACA,SAASC,QAAT,EAAmBC,OAAnB,QAAkC,WAAlC;AACA,SAASC,gBAAT,QAAiC,wBAAjC;AACA,SAASC,cAAT,QAA+B,sBAA/B;AACA,SAASC,YAAT,QAA6B,eAA7B;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,KAAD,EAAW;AAClC,SAAQA,KAAK,KAAK,IAAV,IACJ,EAAE,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,UAAhD,CADJ;AAEH,CAHM;AAIP,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACD,KAAD,EAAW;AACjC,SAAOE,KAAK,CAACC,OAAN,CAAcH,KAAd,KACH;AACA,GAAC,EAAEA,KAAK,IAAIA,KAAK,CAACI,MAAM,CAACC,QAAR,CAAhB,CAFL;AAGH,CAJM;AAKP;AACA;AACA;AACA;AACA;;AACA,WAAaC,kBAAb;AACI,8BAAYC,OAAZ,EAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;AAAA;;AAChC,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKE,KAAL,GAAa,EAAb;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACI,MAAR,GAAiB,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AACzC,WAAKD,KAAL,CAAWC,CAAX,IAAgB,KAAKE,WAAL,EAAhB;AACH;AACJ;AACD;AACJ;AACA;;;AAbA;AAAA;AAAA,WAcI,uBAAc;AACV,aAAO,IAAIC,aAAJ,CAAkB,IAAlB,CAAP;AACH;AAhBL;AAAA;AAAA,WAiBI,qBAAY;AACR,UAAMN,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMO,CAAC,GAAGP,OAAO,CAACI,MAAR,GAAiB,CAA3B;AACA,UAAMF,KAAK,GAAG,KAAKA,KAAnB,CAHQ,CAIR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAIK,CAAC,KAAK,CAAN,IAAWP,OAAO,CAAC,CAAD,CAAP,KAAe,EAA1B,IAAgCA,OAAO,CAAC,CAAD,CAAP,KAAe,EAAnD,EAAuD;AACnD,YAAMQ,CAAC,GAAGN,KAAK,CAAC,CAAD,CAAL,CAASX,KAAnB;;AACA,YAAI,OAAOiB,CAAP,KAAa,QAAjB,EAA2B;AACvB,iBAAOC,MAAM,CAACD,CAAD,CAAb;AACH;;AACD,YAAI,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAAChB,UAAU,CAACgB,CAAD,CAAxC,EAA6C;AACzC,iBAAOA,CAAP;AACH;AACJ;;AACD,UAAIE,IAAI,GAAG,EAAX;;AACA,WAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxBO,QAAAA,IAAI,IAAIV,OAAO,CAACG,CAAD,CAAf;AACA,YAAMQ,IAAI,GAAGT,KAAK,CAACC,CAAD,CAAlB;;AACA,YAAIQ,IAAI,KAAKC,SAAb,EAAwB;AACpB,cAAMJ,EAAC,GAAGG,IAAI,CAACpB,KAAf;;AACA,cAAID,WAAW,CAACkB,EAAD,CAAX,IAAkB,CAAChB,UAAU,CAACgB,EAAD,CAAjC,EAAsC;AAClCE,YAAAA,IAAI,IAAI,OAAOF,EAAP,KAAa,QAAb,GAAwBA,EAAxB,GAA4BC,MAAM,CAACD,EAAD,CAA1C;AACH,WAFD,MAGK;AAAA,uDACeA,EADf;AAAA;;AAAA;AACD,kEAAmB;AAAA,oBAARK,CAAQ;AACfH,gBAAAA,IAAI,IAAI,OAAOG,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4BJ,MAAM,CAACI,CAAD,CAA1C;AACH;AAHA;AAAA;AAAA;AAAA;AAAA;AAIJ;AACJ;AACJ;;AACDH,MAAAA,IAAI,IAAIV,OAAO,CAACO,CAAD,CAAf;AACA,aAAOG,IAAP;AACH;AA7DL;AAAA;AAAA,WA8DI,kBAAS;AACL,UAAI,KAAKT,KAAT,EAAgB;AACZ,aAAKA,KAAL,GAAa,KAAb;AACA,aAAKH,OAAL,CAAagB,YAAb,CAA0B,KAAKf,IAA/B,EAAqC,KAAKgB,SAAL,EAArC;AACH;AACJ;AAnEL;;AAAA;AAAA;AAqEA;AACA;AACA;;AACA,WAAaT,aAAb;AACI,yBAAYU,SAAZ,EAAuB;AAAA;;AACnB,SAAKzB,KAAL,GAAaqB,SAAb;AACA,SAAKI,SAAL,GAAiBA,SAAjB;AACH;;AAJL;AAAA;AAAA,WAKI,kBAASzB,KAAT,EAAgB;AACZ,UAAIA,KAAK,KAAKN,QAAV,KAAuB,CAACK,WAAW,CAACC,KAAD,CAAZ,IAAuBA,KAAK,KAAK,KAAKA,KAA7D,CAAJ,EAAyE;AACrE,aAAKA,KAAL,GAAaA,KAAb,CADqE,CAErE;AACA;AACA;;AACA,YAAI,CAACR,WAAW,CAACQ,KAAD,CAAhB,EAAyB;AACrB,eAAKyB,SAAL,CAAef,KAAf,GAAuB,IAAvB;AACH;AACJ;AACJ;AAfL;AAAA;AAAA,WAgBI,kBAAS;AACL,aAAOlB,WAAW,CAAC,KAAKQ,KAAN,CAAlB,EAAgC;AAC5B,YAAM0B,SAAS,GAAG,KAAK1B,KAAvB;AACA,aAAKA,KAAL,GAAaN,QAAb;AACAgC,QAAAA,SAAS,CAAC,IAAD,CAAT;AACH;;AACD,UAAI,KAAK1B,KAAL,KAAeN,QAAnB,EAA6B;AACzB;AACH;;AACD,WAAK+B,SAAL,CAAeE,MAAf;AACH;AA1BL;;AAAA;AAAA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,QAAb;AACI,oBAAYC,OAAZ,EAAqB;AAAA;;AACjB,SAAK7B,KAAL,GAAaqB,SAAb;AACA,SAAKS,cAAL,GAAsBT,SAAtB;AACA,SAAKQ,OAAL,GAAeA,OAAf;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAVA;AAAA;AAAA,WAWI,oBAAWE,SAAX,EAAsB;AAClB,WAAKC,SAAL,GAAiBD,SAAS,CAACE,WAAV,CAAsBnC,YAAY,EAAlC,CAAjB;AACA,WAAKoC,OAAL,GAAeH,SAAS,CAACE,WAAV,CAAsBnC,YAAY,EAAlC,CAAf;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AArBA;AAAA;AAAA,WAsBI,yBAAgBqC,GAAhB,EAAqB;AACjB,WAAKH,SAAL,GAAiBG,GAAjB;AACA,WAAKD,OAAL,GAAeC,GAAG,CAACC,WAAnB;AACH;AACD;AACJ;AACA;AACA;AACA;;AA9BA;AAAA;AAAA,WA+BI,wBAAehB,IAAf,EAAqB;AACjBA,MAAAA,IAAI,CAACiB,QAAL,CAAc,KAAKL,SAAL,GAAiBlC,YAAY,EAA3C;;AACAsB,MAAAA,IAAI,CAACiB,QAAL,CAAc,KAAKH,OAAL,GAAepC,YAAY,EAAzC;AACH;AACD;AACJ;AACA;AACA;AACA;;AAvCA;AAAA;AAAA,WAwCI,yBAAgBqC,GAAhB,EAAqB;AACjBA,MAAAA,GAAG,CAACE,QAAJ,CAAa,KAAKL,SAAL,GAAiBlC,YAAY,EAA1C;;AACA,WAAKoC,OAAL,GAAeC,GAAG,CAACD,OAAnB;AACAC,MAAAA,GAAG,CAACD,OAAJ,GAAc,KAAKF,SAAnB;AACH;AA5CL;AAAA;AAAA,WA6CI,kBAAShC,KAAT,EAAgB;AACZ,WAAK8B,cAAL,GAAsB9B,KAAtB;AACH;AA/CL;AAAA;AAAA,WAgDI,kBAAS;AACL,UAAI,KAAKgC,SAAL,CAAeM,UAAf,KAA8B,IAAlC,EAAwC;AACpC;AACH;;AACD,aAAO9C,WAAW,CAAC,KAAKsC,cAAN,CAAlB,EAAyC;AACrC,YAAMJ,SAAS,GAAG,KAAKI,cAAvB;AACA,aAAKA,cAAL,GAAsBpC,QAAtB;AACAgC,QAAAA,SAAS,CAAC,IAAD,CAAT;AACH;;AACD,UAAM1B,KAAK,GAAG,KAAK8B,cAAnB;;AACA,UAAI9B,KAAK,KAAKN,QAAd,EAAwB;AACpB;AACH;;AACD,UAAIK,WAAW,CAACC,KAAD,CAAf,EAAwB;AACpB,YAAIA,KAAK,KAAK,KAAKA,KAAnB,EAA0B;AACtB,eAAKuC,YAAL,CAAkBvC,KAAlB;AACH;AACJ,OAJD,MAKK,IAAIA,KAAK,YAAYH,cAArB,EAAqC;AACtC,aAAK2C,sBAAL,CAA4BxC,KAA5B;AACH,OAFI,MAGA,IAAIA,KAAK,YAAYyC,IAArB,EAA2B;AAC5B,aAAKC,YAAL,CAAkB1C,KAAlB;AACH,OAFI,MAGA,IAAIC,UAAU,CAACD,KAAD,CAAd,EAAuB;AACxB,aAAK2C,gBAAL,CAAsB3C,KAAtB;AACH,OAFI,MAGA,IAAIA,KAAK,KAAKL,OAAd,EAAuB;AACxB,aAAKK,KAAL,GAAaL,OAAb;AACA,aAAKiD,KAAL;AACH,OAHI,MAIA;AACD;AACA,aAAKL,YAAL,CAAkBvC,KAAlB;AACH;AACJ;AAnFL;AAAA;AAAA,WAoFI,kBAAS6C,IAAT,EAAe;AACX,WAAKX,OAAL,CAAaI,UAAb,CAAwBQ,YAAxB,CAAqCD,IAArC,EAA2C,KAAKX,OAAhD;AACH;AAtFL;AAAA;AAAA,WAuFI,sBAAalC,KAAb,EAAoB;AAChB,UAAI,KAAKA,KAAL,KAAeA,KAAnB,EAA0B;AACtB;AACH;;AACD,WAAK4C,KAAL;;AACA,WAAKP,QAAL,CAAcrC,KAAd;;AACA,WAAKA,KAAL,GAAaA,KAAb;AACH;AA9FL;AAAA;AAAA,WA+FI,sBAAaA,KAAb,EAAoB;AAChB,UAAM6C,IAAI,GAAG,KAAKb,SAAL,CAAeI,WAA5B;AACApC,MAAAA,KAAK,GAAGA,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqBA,KAA7B,CAFgB,CAGhB;AACA;;AACA,UAAM+C,aAAa,GAAG,OAAO/C,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCkB,MAAM,CAAClB,KAAD,CAAhE;;AACA,UAAI6C,IAAI,KAAK,KAAKX,OAAL,CAAac,eAAtB,IACAH,IAAI,CAACI,QAAL,KAAkB;AAAE;AADxB,QAC8C;AAC1C;AACA;AACA;AACAJ,UAAAA,IAAI,CAACK,IAAL,GAAYH,aAAZ;AACH,SAND,MAOK;AACD,aAAKL,YAAL,CAAkBS,QAAQ,CAACC,cAAT,CAAwBL,aAAxB,CAAlB;AACH;;AACD,WAAK/C,KAAL,GAAaA,KAAb;AACH;AAhHL;AAAA;AAAA,WAiHI,gCAAuBA,KAAvB,EAA8B;AAC1B,UAAMqD,QAAQ,GAAG,KAAKxB,OAAL,CAAayB,eAAb,CAA6BtD,KAA7B,CAAjB;;AACA,UAAI,KAAKA,KAAL,YAAsBJ,gBAAtB,IACA,KAAKI,KAAL,CAAWqD,QAAX,KAAwBA,QAD5B,EACsC;AAClC,aAAKrD,KAAL,CAAWuD,MAAX,CAAkBvD,KAAK,CAACwD,MAAxB;AACH,OAHD,MAIK;AACD;AACA;AACA;AACA;AACA,YAAMC,QAAQ,GAAG,IAAI7D,gBAAJ,CAAqByD,QAArB,EAA+BrD,KAAK,CAAC0D,SAArC,EAAgD,KAAK7B,OAArD,CAAjB;;AACA,YAAM8B,QAAQ,GAAGF,QAAQ,CAACG,MAAT,EAAjB;;AACAH,QAAAA,QAAQ,CAACF,MAAT,CAAgBvD,KAAK,CAACwD,MAAtB;;AACA,aAAKd,YAAL,CAAkBiB,QAAlB;;AACA,aAAK3D,KAAL,GAAayD,QAAb;AACH;AACJ;AAlIL;AAAA;AAAA,WAmII,0BAAiBzD,KAAjB,EAAwB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAI,CAACE,KAAK,CAACC,OAAN,CAAc,KAAKH,KAAnB,CAAL,EAAgC;AAC5B,aAAKA,KAAL,GAAa,EAAb;AACA,aAAK4C,KAAL;AACH,OAbmB,CAcpB;AACA;;;AACA,UAAMiB,SAAS,GAAG,KAAK7D,KAAvB;AACA,UAAI8D,SAAS,GAAG,CAAhB;AACA,UAAIC,QAAJ;;AAlBoB,kDAmBD/D,KAnBC;AAAA;;AAAA;AAmBpB,+DAA0B;AAAA,cAAfgE,IAAe;AACtB;AACAD,UAAAA,QAAQ,GAAGF,SAAS,CAACC,SAAD,CAApB,CAFsB,CAGtB;;AACA,cAAIC,QAAQ,KAAK1C,SAAjB,EAA4B;AACxB0C,YAAAA,QAAQ,GAAG,IAAInC,QAAJ,CAAa,KAAKC,OAAlB,CAAX;AACAgC,YAAAA,SAAS,CAACI,IAAV,CAAeF,QAAf;;AACA,gBAAID,SAAS,KAAK,CAAlB,EAAqB;AACjBC,cAAAA,QAAQ,CAACG,cAAT,CAAwB,IAAxB;AACH,aAFD,MAGK;AACDH,cAAAA,QAAQ,CAACI,eAAT,CAAyBN,SAAS,CAACC,SAAS,GAAG,CAAb,CAAlC;AACH;AACJ;;AACDC,UAAAA,QAAQ,CAACK,QAAT,CAAkBJ,IAAlB;AACAD,UAAAA,QAAQ,CAACpC,MAAT;AACAmC,UAAAA,SAAS;AACZ;AApCmB;AAAA;AAAA;AAAA;AAAA;;AAqCpB,UAAIA,SAAS,GAAGD,SAAS,CAAChD,MAA1B,EAAkC;AAC9B;AACAgD,QAAAA,SAAS,CAAChD,MAAV,GAAmBiD,SAAnB;AACA,aAAKlB,KAAL,CAAWmB,QAAQ,IAAIA,QAAQ,CAAC7B,OAAhC;AACH;AACJ;AA7KL;AAAA;AAAA,WA8KI,iBAAkC;AAAA,UAA5BF,SAA4B,uEAAhB,KAAKA,SAAW;AAC9BvC,MAAAA,WAAW,CAAC,KAAKuC,SAAL,CAAeM,UAAhB,EAA4BN,SAAS,CAACI,WAAtC,EAAmD,KAAKF,OAAxD,CAAX;AACH;AAhLL;;AAAA;AAAA;AAkLA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAamC,oBAAb;AACI,gCAAY9D,OAAZ,EAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;AAAA;;AAChC,SAAKT,KAAL,GAAaqB,SAAb;AACA,SAAKS,cAAL,GAAsBT,SAAtB;;AACA,QAAIZ,OAAO,CAACI,MAAR,KAAmB,CAAnB,IAAwBJ,OAAO,CAAC,CAAD,CAAP,KAAe,EAAvC,IAA6CA,OAAO,CAAC,CAAD,CAAP,KAAe,EAAhE,EAAoE;AAChE,YAAM,IAAI6D,KAAJ,CAAU,yDAAV,CAAN;AACH;;AACD,SAAK/D,OAAL,GAAeA,OAAf;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACH;;AAVL;AAAA;AAAA,WAWI,kBAAST,KAAT,EAAgB;AACZ,WAAK8B,cAAL,GAAsB9B,KAAtB;AACH;AAbL;AAAA;AAAA,WAcI,kBAAS;AACL,aAAOR,WAAW,CAAC,KAAKsC,cAAN,CAAlB,EAAyC;AACrC,YAAMJ,SAAS,GAAG,KAAKI,cAAvB;AACA,aAAKA,cAAL,GAAsBpC,QAAtB;AACAgC,QAAAA,SAAS,CAAC,IAAD,CAAT;AACH;;AACD,UAAI,KAAKI,cAAL,KAAwBpC,QAA5B,EAAsC;AAClC;AACH;;AACD,UAAMM,KAAK,GAAG,CAAC,CAAC,KAAK8B,cAArB;;AACA,UAAI,KAAK9B,KAAL,KAAeA,KAAnB,EAA0B;AACtB,YAAIA,KAAJ,EAAW;AACP,eAAKO,OAAL,CAAagB,YAAb,CAA0B,KAAKf,IAA/B,EAAqC,EAArC;AACH,SAFD,MAGK;AACD,eAAKD,OAAL,CAAagE,eAAb,CAA6B,KAAK/D,IAAlC;AACH;;AACD,aAAKR,KAAL,GAAaA,KAAb;AACH;;AACD,WAAK8B,cAAL,GAAsBpC,QAAtB;AACH;AAlCL;;AAAA;AAAA;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAa8E,iBAAb;AAAA;;AAAA;;AACI,6BAAYjE,OAAZ,EAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;AAAA;;AAAA;;AAChC,8BAAMF,OAAN,EAAeC,IAAf,EAAqBC,OAArB;AACA,UAAKgE,MAAL,GACKhE,OAAO,CAACI,MAAR,KAAmB,CAAnB,IAAwBJ,OAAO,CAAC,CAAD,CAAP,KAAe,EAAvC,IAA6CA,OAAO,CAAC,CAAD,CAAP,KAAe,EADjE;AAFgC;AAInC;;AALL;AAAA;AAAA,WAMI,uBAAc;AACV,aAAO,IAAIiE,YAAJ,CAAiB,IAAjB,CAAP;AACH;AARL;AAAA;AAAA,WASI,qBAAY;AACR,UAAI,KAAKD,MAAT,EAAiB;AACb,eAAO,KAAK9D,KAAL,CAAW,CAAX,EAAcX,KAArB;AACH;;AACD;AACH;AAdL;AAAA;AAAA,WAeI,kBAAS;AACL,UAAI,KAAKU,KAAT,EAAgB;AACZ,aAAKA,KAAL,GAAa,KAAb,CADY,CAEZ;;AACA,aAAKH,OAAL,CAAa,KAAKC,IAAlB,IAA0B,KAAKgB,SAAL,EAA1B;AACH;AACJ;AArBL;;AAAA;AAAA,EAAuClB,kBAAvC;AAuBA,WAAaoE,YAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,EAAkC3D,aAAlC,E,CAEA;AACA;AACA;AACA;;AACA,IAAI4D,qBAAqB,GAAG,KAA5B,C,CACA;AACA;;AACA,CAAC,YAAM;AACH,MAAI;AACA,QAAM9C,OAAO,GAAG;AACZ,UAAI+C,OAAJ,GAAc;AACVD,QAAAA,qBAAqB,GAAG,IAAxB;AACA,eAAO,KAAP;AACH;;AAJW,KAAhB,CADA,CAOA;;AACAE,IAAAA,MAAM,CAACC,gBAAP,CAAwB,MAAxB,EAAgCjD,OAAhC,EAAyCA,OAAzC,EARA,CASA;;AACAgD,IAAAA,MAAM,CAACE,mBAAP,CAA2B,MAA3B,EAAmClD,OAAnC,EAA4CA,OAA5C;AACH,GAXD,CAYA,OAAOmD,EAAP,EAAW,CACP;AACH;AACJ,CAhBD;;AAiBA,WAAaC,SAAb;AACI,qBAAY1E,OAAZ,EAAqB2E,SAArB,EAAgCC,YAAhC,EAA8C;AAAA;;AAAA;;AAC1C,SAAKnF,KAAL,GAAaqB,SAAb;AACA,SAAKS,cAAL,GAAsBT,SAAtB;AACA,SAAKd,OAAL,GAAeA,OAAf;AACA,SAAK2E,SAAL,GAAiBA,SAAjB;AACA,SAAKC,YAAL,GAAoBA,YAApB;;AACA,SAAKC,kBAAL,GAA0B,UAACC,CAAD;AAAA,aAAO,MAAI,CAACC,WAAL,CAAiBD,CAAjB,CAAP;AAAA,KAA1B;AACH;;AARL;AAAA;AAAA,WASI,kBAASrF,KAAT,EAAgB;AACZ,WAAK8B,cAAL,GAAsB9B,KAAtB;AACH;AAXL;AAAA;AAAA,WAYI,kBAAS;AACL,aAAOR,WAAW,CAAC,KAAKsC,cAAN,CAAlB,EAAyC;AACrC,YAAMJ,SAAS,GAAG,KAAKI,cAAvB;AACA,aAAKA,cAAL,GAAsBpC,QAAtB;AACAgC,QAAAA,SAAS,CAAC,IAAD,CAAT;AACH;;AACD,UAAI,KAAKI,cAAL,KAAwBpC,QAA5B,EAAsC;AAClC;AACH;;AACD,UAAM6F,WAAW,GAAG,KAAKzD,cAAzB;AACA,UAAM0D,WAAW,GAAG,KAAKxF,KAAzB;AACA,UAAMyF,oBAAoB,GAAGF,WAAW,IAAI,IAAf,IACzBC,WAAW,IAAI,IAAf,KACKD,WAAW,CAACX,OAAZ,KAAwBY,WAAW,CAACZ,OAApC,IACGW,WAAW,CAACG,IAAZ,KAAqBF,WAAW,CAACE,IADpC,IAEGH,WAAW,CAACI,OAAZ,KAAwBH,WAAW,CAACG,OAH5C,CADJ;AAKA,UAAMC,iBAAiB,GAAGL,WAAW,IAAI,IAAf,KAAwBC,WAAW,IAAI,IAAf,IAAuBC,oBAA/C,CAA1B;;AACA,UAAIA,oBAAJ,EAA0B;AACtB,aAAKlF,OAAL,CAAawE,mBAAb,CAAiC,KAAKG,SAAtC,EAAiD,KAAKE,kBAAtD,EAA0E,KAAKS,SAA/E;AACH;;AACD,UAAID,iBAAJ,EAAuB;AACnB,aAAKC,SAAL,GAAiBC,UAAU,CAACP,WAAD,CAA3B;AACA,aAAKhF,OAAL,CAAauE,gBAAb,CAA8B,KAAKI,SAAnC,EAA8C,KAAKE,kBAAnD,EAAuE,KAAKS,SAA5E;AACH;;AACD,WAAK7F,KAAL,GAAauF,WAAb;AACA,WAAKzD,cAAL,GAAsBpC,QAAtB;AACH;AAtCL;AAAA;AAAA,WAuCI,qBAAYqG,KAAZ,EAAmB;AACf,UAAI,OAAO,KAAK/F,KAAZ,KAAsB,UAA1B,EAAsC;AAClC,aAAKA,KAAL,CAAWgG,IAAX,CAAgB,KAAKb,YAAL,IAAqB,KAAK5E,OAA1C,EAAmDwF,KAAnD;AACH,OAFD,MAGK;AACD,aAAK/F,KAAL,CAAWsF,WAAX,CAAuBS,KAAvB;AACH;AACJ;AA9CL;;AAAA;AAAA,I,CAgDA;AACA;AACA;;AACA,IAAMD,UAAU,GAAG,SAAbA,UAAa,CAACG,CAAD;AAAA,SAAOA,CAAC,KACtBtB,qBAAqB,GAClB;AAAEC,IAAAA,OAAO,EAAEqB,CAAC,CAACrB,OAAb;AAAsBe,IAAAA,OAAO,EAAEM,CAAC,CAACN,OAAjC;AAA0CD,IAAAA,IAAI,EAAEO,CAAC,CAACP;AAAlD,GADkB,GAElBO,CAAC,CAACrB,OAHiB,CAAR;AAAA,CAAnB,C,CAIA","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { isDirective } from './directive.js';\r\nimport { removeNodes } from './dom.js';\r\nimport { noChange, nothing } from './part.js';\r\nimport { TemplateInstance } from './template-instance.js';\r\nimport { TemplateResult } from './template-result.js';\r\nimport { createMarker } from './template.js';\r\nexport const isPrimitive = (value) => {\r\n    return (value === null ||\r\n        !(typeof value === 'object' || typeof value === 'function'));\r\n};\r\nexport const isIterable = (value) => {\r\n    return Array.isArray(value) ||\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        !!(value && value[Symbol.iterator]);\r\n};\r\n/**\r\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\r\n * single attribute. The value is only set once even if there are multiple parts\r\n * for an attribute.\r\n */\r\nexport class AttributeCommitter {\r\n    constructor(element, name, strings) {\r\n        this.dirty = true;\r\n        this.element = element;\r\n        this.name = name;\r\n        this.strings = strings;\r\n        this.parts = [];\r\n        for (let i = 0; i < strings.length - 1; i++) {\r\n            this.parts[i] = this._createPart();\r\n        }\r\n    }\r\n    /**\r\n     * Creates a single part. Override this to create a differnt type of part.\r\n     */\r\n    _createPart() {\r\n        return new AttributePart(this);\r\n    }\r\n    _getValue() {\r\n        const strings = this.strings;\r\n        const l = strings.length - 1;\r\n        const parts = this.parts;\r\n        // If we're assigning an attribute via syntax like:\r\n        //    attr=\"${foo}\"  or  attr=${foo}\r\n        // but not\r\n        //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\r\n        // then we don't want to coerce the attribute value into one long\r\n        // string. Instead we want to just return the value itself directly,\r\n        // so that sanitizeDOMValue can get the actual value rather than\r\n        // String(value)\r\n        // The exception is if v is an array, in which case we do want to smash\r\n        // it together into a string without calling String() on the array.\r\n        //\r\n        // This also allows trusted values (when using TrustedTypes) being\r\n        // assigned to DOM sinks without being stringified in the process.\r\n        if (l === 1 && strings[0] === '' && strings[1] === '') {\r\n            const v = parts[0].value;\r\n            if (typeof v === 'symbol') {\r\n                return String(v);\r\n            }\r\n            if (typeof v === 'string' || !isIterable(v)) {\r\n                return v;\r\n            }\r\n        }\r\n        let text = '';\r\n        for (let i = 0; i < l; i++) {\r\n            text += strings[i];\r\n            const part = parts[i];\r\n            if (part !== undefined) {\r\n                const v = part.value;\r\n                if (isPrimitive(v) || !isIterable(v)) {\r\n                    text += typeof v === 'string' ? v : String(v);\r\n                }\r\n                else {\r\n                    for (const t of v) {\r\n                        text += typeof t === 'string' ? t : String(t);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        text += strings[l];\r\n        return text;\r\n    }\r\n    commit() {\r\n        if (this.dirty) {\r\n            this.dirty = false;\r\n            this.element.setAttribute(this.name, this._getValue());\r\n        }\r\n    }\r\n}\r\n/**\r\n * A Part that controls all or part of an attribute value.\r\n */\r\nexport class AttributePart {\r\n    constructor(committer) {\r\n        this.value = undefined;\r\n        this.committer = committer;\r\n    }\r\n    setValue(value) {\r\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\r\n            this.value = value;\r\n            // If the value is a not a directive, dirty the committer so that it'll\r\n            // call setAttribute. If the value is a directive, it'll dirty the\r\n            // committer if it calls setValue().\r\n            if (!isDirective(value)) {\r\n                this.committer.dirty = true;\r\n            }\r\n        }\r\n    }\r\n    commit() {\r\n        while (isDirective(this.value)) {\r\n            const directive = this.value;\r\n            this.value = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.value === noChange) {\r\n            return;\r\n        }\r\n        this.committer.commit();\r\n    }\r\n}\r\n/**\r\n * A Part that controls a location within a Node tree. Like a Range, NodePart\r\n * has start and end locations and can set and update the Nodes between those\r\n * locations.\r\n *\r\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\r\n * as well as arrays and iterables of those types.\r\n */\r\nexport class NodePart {\r\n    constructor(options) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Appends this part into a container.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendInto(container) {\r\n        this.startNode = container.appendChild(createMarker());\r\n        this.endNode = container.appendChild(createMarker());\r\n    }\r\n    /**\r\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\r\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\r\n     * such as those that appear in a literal section of a template.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterNode(ref) {\r\n        this.startNode = ref;\r\n        this.endNode = ref.nextSibling;\r\n    }\r\n    /**\r\n     * Appends this part into a parent part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    appendIntoPart(part) {\r\n        part.__insert(this.startNode = createMarker());\r\n        part.__insert(this.endNode = createMarker());\r\n    }\r\n    /**\r\n     * Inserts this part after the `ref` part.\r\n     *\r\n     * This part must be empty, as its contents are not automatically moved.\r\n     */\r\n    insertAfterPart(ref) {\r\n        ref.__insert(this.startNode = createMarker());\r\n        this.endNode = ref.endNode;\r\n        ref.endNode = this.startNode;\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        if (this.startNode.parentNode === null) {\r\n            return;\r\n        }\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        const value = this.__pendingValue;\r\n        if (value === noChange) {\r\n            return;\r\n        }\r\n        if (isPrimitive(value)) {\r\n            if (value !== this.value) {\r\n                this.__commitText(value);\r\n            }\r\n        }\r\n        else if (value instanceof TemplateResult) {\r\n            this.__commitTemplateResult(value);\r\n        }\r\n        else if (value instanceof Node) {\r\n            this.__commitNode(value);\r\n        }\r\n        else if (isIterable(value)) {\r\n            this.__commitIterable(value);\r\n        }\r\n        else if (value === nothing) {\r\n            this.value = nothing;\r\n            this.clear();\r\n        }\r\n        else {\r\n            // Fallback, will render the string representation\r\n            this.__commitText(value);\r\n        }\r\n    }\r\n    __insert(node) {\r\n        this.endNode.parentNode.insertBefore(node, this.endNode);\r\n    }\r\n    __commitNode(value) {\r\n        if (this.value === value) {\r\n            return;\r\n        }\r\n        this.clear();\r\n        this.__insert(value);\r\n        this.value = value;\r\n    }\r\n    __commitText(value) {\r\n        const node = this.startNode.nextSibling;\r\n        value = value == null ? '' : value;\r\n        // If `value` isn't already a string, we explicitly convert it here in case\r\n        // it can't be implicitly converted - i.e. it's a symbol.\r\n        const valueAsString = typeof value === 'string' ? value : String(value);\r\n        if (node === this.endNode.previousSibling &&\r\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\r\n            // If we only have a single text node between the markers, we can just\r\n            // set its value, rather than replacing it.\r\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\r\n            node.data = valueAsString;\r\n        }\r\n        else {\r\n            this.__commitNode(document.createTextNode(valueAsString));\r\n        }\r\n        this.value = value;\r\n    }\r\n    __commitTemplateResult(value) {\r\n        const template = this.options.templateFactory(value);\r\n        if (this.value instanceof TemplateInstance &&\r\n            this.value.template === template) {\r\n            this.value.update(value.values);\r\n        }\r\n        else {\r\n            // Make sure we propagate the template processor from the TemplateResult\r\n            // so that we use its syntax extension, etc. The template factory comes\r\n            // from the render function options so that it can control template\r\n            // caching and preprocessing.\r\n            const instance = new TemplateInstance(template, value.processor, this.options);\r\n            const fragment = instance._clone();\r\n            instance.update(value.values);\r\n            this.__commitNode(fragment);\r\n            this.value = instance;\r\n        }\r\n    }\r\n    __commitIterable(value) {\r\n        // For an Iterable, we create a new InstancePart per item, then set its\r\n        // value to the item. This is a little bit of overhead for every item in\r\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\r\n        // of TemplateResults that will be commonly returned from expressions like:\r\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\r\n        // If _value is an array, then the previous render was of an\r\n        // iterable and _value will contain the NodeParts from the previous\r\n        // render. If _value is not an array, clear this part and make a new\r\n        // array for NodeParts.\r\n        if (!Array.isArray(this.value)) {\r\n            this.value = [];\r\n            this.clear();\r\n        }\r\n        // Lets us keep track of how many items we stamped so we can clear leftover\r\n        // items from a previous render\r\n        const itemParts = this.value;\r\n        let partIndex = 0;\r\n        let itemPart;\r\n        for (const item of value) {\r\n            // Try to reuse an existing part\r\n            itemPart = itemParts[partIndex];\r\n            // If no existing part, create a new one\r\n            if (itemPart === undefined) {\r\n                itemPart = new NodePart(this.options);\r\n                itemParts.push(itemPart);\r\n                if (partIndex === 0) {\r\n                    itemPart.appendIntoPart(this);\r\n                }\r\n                else {\r\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\r\n                }\r\n            }\r\n            itemPart.setValue(item);\r\n            itemPart.commit();\r\n            partIndex++;\r\n        }\r\n        if (partIndex < itemParts.length) {\r\n            // Truncate the parts array so _value reflects the current state\r\n            itemParts.length = partIndex;\r\n            this.clear(itemPart && itemPart.endNode);\r\n        }\r\n    }\r\n    clear(startNode = this.startNode) {\r\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\r\n    }\r\n}\r\n/**\r\n * Implements a boolean attribute, roughly as defined in the HTML\r\n * specification.\r\n *\r\n * If the value is truthy, then the attribute is present with a value of\r\n * ''. If the value is falsey, the attribute is removed.\r\n */\r\nexport class BooleanAttributePart {\r\n    constructor(element, name, strings) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\r\n            throw new Error('Boolean attributes can only contain a single expression');\r\n        }\r\n        this.element = element;\r\n        this.name = name;\r\n        this.strings = strings;\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.__pendingValue === noChange) {\r\n            return;\r\n        }\r\n        const value = !!this.__pendingValue;\r\n        if (this.value !== value) {\r\n            if (value) {\r\n                this.element.setAttribute(this.name, '');\r\n            }\r\n            else {\r\n                this.element.removeAttribute(this.name);\r\n            }\r\n            this.value = value;\r\n        }\r\n        this.__pendingValue = noChange;\r\n    }\r\n}\r\n/**\r\n * Sets attribute values for PropertyParts, so that the value is only set once\r\n * even if there are multiple parts for a property.\r\n *\r\n * If an expression controls the whole property value, then the value is simply\r\n * assigned to the property under control. If there are string literals or\r\n * multiple expressions, then the strings are expressions are interpolated into\r\n * a string first.\r\n */\r\nexport class PropertyCommitter extends AttributeCommitter {\r\n    constructor(element, name, strings) {\r\n        super(element, name, strings);\r\n        this.single =\r\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\r\n    }\r\n    _createPart() {\r\n        return new PropertyPart(this);\r\n    }\r\n    _getValue() {\r\n        if (this.single) {\r\n            return this.parts[0].value;\r\n        }\r\n        return super._getValue();\r\n    }\r\n    commit() {\r\n        if (this.dirty) {\r\n            this.dirty = false;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.element[this.name] = this._getValue();\r\n        }\r\n    }\r\n}\r\nexport class PropertyPart extends AttributePart {\r\n}\r\n// Detect event listener options support. If the `capture` property is read\r\n// from the options object, then options are supported. If not, then the third\r\n// argument to add/removeEventListener is interpreted as the boolean capture\r\n// value so we should only pass the `capture` property.\r\nlet eventOptionsSupported = false;\r\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\r\n// blocks right into the body of a module\r\n(() => {\r\n    try {\r\n        const options = {\r\n            get capture() {\r\n                eventOptionsSupported = true;\r\n                return false;\r\n            }\r\n        };\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        window.addEventListener('test', options, options);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        window.removeEventListener('test', options, options);\r\n    }\r\n    catch (_e) {\r\n        // event options not supported\r\n    }\r\n})();\r\nexport class EventPart {\r\n    constructor(element, eventName, eventContext) {\r\n        this.value = undefined;\r\n        this.__pendingValue = undefined;\r\n        this.element = element;\r\n        this.eventName = eventName;\r\n        this.eventContext = eventContext;\r\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\r\n    }\r\n    setValue(value) {\r\n        this.__pendingValue = value;\r\n    }\r\n    commit() {\r\n        while (isDirective(this.__pendingValue)) {\r\n            const directive = this.__pendingValue;\r\n            this.__pendingValue = noChange;\r\n            directive(this);\r\n        }\r\n        if (this.__pendingValue === noChange) {\r\n            return;\r\n        }\r\n        const newListener = this.__pendingValue;\r\n        const oldListener = this.value;\r\n        const shouldRemoveListener = newListener == null ||\r\n            oldListener != null &&\r\n                (newListener.capture !== oldListener.capture ||\r\n                    newListener.once !== oldListener.once ||\r\n                    newListener.passive !== oldListener.passive);\r\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\r\n        if (shouldRemoveListener) {\r\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\r\n        }\r\n        if (shouldAddListener) {\r\n            this.__options = getOptions(newListener);\r\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\r\n        }\r\n        this.value = newListener;\r\n        this.__pendingValue = noChange;\r\n    }\r\n    handleEvent(event) {\r\n        if (typeof this.value === 'function') {\r\n            this.value.call(this.eventContext || this.element, event);\r\n        }\r\n        else {\r\n            this.value.handleEvent(event);\r\n        }\r\n    }\r\n}\r\n// We copy options because of the inconsistent behavior of browsers when reading\r\n// the third argument of add/removeEventListener. IE11 doesn't support options\r\n// at all. Chrome 41 only reads `capture` if the argument is an object.\r\nconst getOptions = (o) => o &&\r\n    (eventOptionsSupported ?\r\n        { capture: o.capture, passive: o.passive, once: o.once } :\r\n        o.capture);\r\n//# sourceMappingURL=parts.js.map"]},"metadata":{},"sourceType":"module"}