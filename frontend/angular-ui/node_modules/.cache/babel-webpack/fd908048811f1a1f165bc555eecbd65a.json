{"ast":null,"code":"import _toConsumableArray from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\r\n * An instance of a `Template` that can be attached to the DOM and updated\r\n * with new values.\r\n */\n\nexport var TemplateInstance = /*#__PURE__*/function () {\n  function TemplateInstance(template, processor, options) {\n    _classCallCheck(this, TemplateInstance);\n\n    this.__parts = [];\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  _createClass(TemplateInstance, [{\n    key: \"update\",\n    value: function update(values) {\n      var i = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.__parts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var part = _step.value;\n\n          if (part !== undefined) {\n            part.setValue(values[i]);\n          }\n\n          i++;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.__parts),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _part = _step2.value;\n\n          if (_part !== undefined) {\n            _part.commit();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      // There are a number of steps in the lifecycle of a template instance's\n      // DOM fragment:\n      //  1. Clone - create the instance fragment\n      //  2. Adopt - adopt into the main document\n      //  3. Process - find part markers and create parts\n      //  4. Upgrade - upgrade custom elements\n      //  5. Update - set node, attribute, property, etc., values\n      //  6. Connect - connect to the document. Optional and outside of this\n      //     method.\n      //\n      // We have a few constraints on the ordering of these steps:\n      //  * We need to upgrade before updating, so that property values will pass\n      //    through any property setters.\n      //  * We would like to process before upgrading so that we're sure that the\n      //    cloned fragment is inert and not disturbed by self-modifying DOM.\n      //  * We want custom elements to upgrade even in disconnected fragments.\n      //\n      // Given these constraints, with full custom elements support we would\n      // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n      //\n      // But Safari does not implement CustomElementRegistry#upgrade, so we\n      // can not implement that order and still have upgrade-before-update and\n      // upgrade disconnected fragments. So we instead sacrifice the\n      // process-before-upgrade constraint, since in Custom Elements v1 elements\n      // must not modify their light DOM in the constructor. We still have issues\n      // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n      // that don't strictly adhere to the no-modification rule because shadow\n      // DOM, which may be created in the constructor, is emulated by being placed\n      // in the light DOM.\n      //\n      // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n      // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n      // in one step.\n      //\n      // The Custom Elements v1 polyfill supports upgrade(), so the order when\n      // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n      // Connect.\n      var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);\n      var stack = [];\n      var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\n      var walker = document.createTreeWalker(fragment, 133\n      /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n      , null, false);\n      var partIndex = 0;\n      var nodeIndex = 0;\n      var part;\n      var node = walker.nextNode(); // Loop through all the nodes and parts of a template\n\n      while (partIndex < parts.length) {\n        part = parts[partIndex];\n\n        if (!isTemplatePartActive(part)) {\n          this.__parts.push(undefined);\n\n          partIndex++;\n          continue;\n        } // Progress the tree walker until we find our next part's node.\n        // Note that multiple parts may share the same node (attribute parts\n        // on a single element), so this loop may not run at all.\n\n\n        while (nodeIndex < part.index) {\n          nodeIndex++;\n\n          if (node.nodeName === 'TEMPLATE') {\n            stack.push(node);\n            walker.currentNode = node.content;\n          }\n\n          if ((node = walker.nextNode()) === null) {\n            // We've exhausted the content inside a nested template element.\n            // Because we still have parts (the outer for-loop), we know:\n            // - There is a template in the stack\n            // - The walker will find a nextNode outside the template\n            walker.currentNode = stack.pop();\n            node = walker.nextNode();\n          }\n        } // We've arrived at our part's node.\n\n\n        if (part.type === 'node') {\n          var _part2 = this.processor.handleTextExpression(this.options);\n\n          _part2.insertAfterNode(node.previousSibling);\n\n          this.__parts.push(_part2);\n        } else {\n          var _this$__parts;\n\n          (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));\n        }\n\n        partIndex++;\n      }\n\n      if (isCEPolyfill) {\n        document.adoptNode(fragment);\n        customElements.upgrade(fragment);\n      }\n\n      return fragment;\n    }\n  }]);\n\n  return TemplateInstance;\n}(); //# sourceMappingURL=template-instance.js.map","map":{"version":3,"sources":["C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/lit-html/lib/template-instance.js"],"names":["isCEPolyfill","isTemplatePartActive","TemplateInstance","template","processor","options","__parts","values","i","part","undefined","setValue","commit","fragment","element","content","cloneNode","document","importNode","stack","parts","walker","createTreeWalker","partIndex","nodeIndex","node","nextNode","length","push","index","nodeName","currentNode","pop","type","handleTextExpression","insertAfterNode","previousSibling","handleAttributeExpressions","name","strings","adoptNode","customElements","upgrade"],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { isCEPolyfill } from './dom.js';\r\nimport { isTemplatePartActive } from './template.js';\r\n/**\r\n * An instance of a `Template` that can be attached to the DOM and updated\r\n * with new values.\r\n */\r\nexport class TemplateInstance {\r\n    constructor(template, processor, options) {\r\n        this.__parts = [];\r\n        this.template = template;\r\n        this.processor = processor;\r\n        this.options = options;\r\n    }\r\n    update(values) {\r\n        let i = 0;\r\n        for (const part of this.__parts) {\r\n            if (part !== undefined) {\r\n                part.setValue(values[i]);\r\n            }\r\n            i++;\r\n        }\r\n        for (const part of this.__parts) {\r\n            if (part !== undefined) {\r\n                part.commit();\r\n            }\r\n        }\r\n    }\r\n    _clone() {\r\n        // There are a number of steps in the lifecycle of a template instance's\r\n        // DOM fragment:\r\n        //  1. Clone - create the instance fragment\r\n        //  2. Adopt - adopt into the main document\r\n        //  3. Process - find part markers and create parts\r\n        //  4. Upgrade - upgrade custom elements\r\n        //  5. Update - set node, attribute, property, etc., values\r\n        //  6. Connect - connect to the document. Optional and outside of this\r\n        //     method.\r\n        //\r\n        // We have a few constraints on the ordering of these steps:\r\n        //  * We need to upgrade before updating, so that property values will pass\r\n        //    through any property setters.\r\n        //  * We would like to process before upgrading so that we're sure that the\r\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\r\n        //  * We want custom elements to upgrade even in disconnected fragments.\r\n        //\r\n        // Given these constraints, with full custom elements support we would\r\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\r\n        //\r\n        // But Safari does not implement CustomElementRegistry#upgrade, so we\r\n        // can not implement that order and still have upgrade-before-update and\r\n        // upgrade disconnected fragments. So we instead sacrifice the\r\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\r\n        // must not modify their light DOM in the constructor. We still have issues\r\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\r\n        // that don't strictly adhere to the no-modification rule because shadow\r\n        // DOM, which may be created in the constructor, is emulated by being placed\r\n        // in the light DOM.\r\n        //\r\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\r\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\r\n        // in one step.\r\n        //\r\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\r\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\r\n        // Connect.\r\n        const fragment = isCEPolyfill ?\r\n            this.template.element.content.cloneNode(true) :\r\n            document.importNode(this.template.element.content, true);\r\n        const stack = [];\r\n        const parts = this.template.parts;\r\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\r\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\r\n        let partIndex = 0;\r\n        let nodeIndex = 0;\r\n        let part;\r\n        let node = walker.nextNode();\r\n        // Loop through all the nodes and parts of a template\r\n        while (partIndex < parts.length) {\r\n            part = parts[partIndex];\r\n            if (!isTemplatePartActive(part)) {\r\n                this.__parts.push(undefined);\r\n                partIndex++;\r\n                continue;\r\n            }\r\n            // Progress the tree walker until we find our next part's node.\r\n            // Note that multiple parts may share the same node (attribute parts\r\n            // on a single element), so this loop may not run at all.\r\n            while (nodeIndex < part.index) {\r\n                nodeIndex++;\r\n                if (node.nodeName === 'TEMPLATE') {\r\n                    stack.push(node);\r\n                    walker.currentNode = node.content;\r\n                }\r\n                if ((node = walker.nextNode()) === null) {\r\n                    // We've exhausted the content inside a nested template element.\r\n                    // Because we still have parts (the outer for-loop), we know:\r\n                    // - There is a template in the stack\r\n                    // - The walker will find a nextNode outside the template\r\n                    walker.currentNode = stack.pop();\r\n                    node = walker.nextNode();\r\n                }\r\n            }\r\n            // We've arrived at our part's node.\r\n            if (part.type === 'node') {\r\n                const part = this.processor.handleTextExpression(this.options);\r\n                part.insertAfterNode(node.previousSibling);\r\n                this.__parts.push(part);\r\n            }\r\n            else {\r\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\r\n            }\r\n            partIndex++;\r\n        }\r\n        if (isCEPolyfill) {\r\n            document.adoptNode(fragment);\r\n            customElements.upgrade(fragment);\r\n        }\r\n        return fragment;\r\n    }\r\n}\r\n//# sourceMappingURL=template-instance.js.map"]},"metadata":{},"sourceType":"module"}