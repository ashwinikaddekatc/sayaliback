{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\n/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\nvar _a;\n/**\r\n * Use this module if you want to create your own base class extending\r\n * [[UpdatingElement]].\r\n * @packageDocumentation\r\n */\n\n/*\r\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\r\n * replaced at compile time by the munged name for object[property]. We cannot\r\n * alias this function, so we have to use a small shim that has the same\r\n * behavior when not compiling.\r\n */\n\n\nwindow.JSCompiler_renameProperty = function (prop, _obj) {\n  return prop;\n};\n\nexport var defaultConverter = {\n  toAttribute: function toAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value ? '' : null;\n\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        return value == null ? value : JSON.stringify(value);\n    }\n\n    return value;\n  },\n  fromAttribute: function fromAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value !== null;\n\n      case Number:\n        return value === null ? null : Number(value);\n\n      case Object:\n      case Array:\n        return JSON.parse(value);\n    }\n\n    return value;\n  }\n};\n/**\r\n * Change function that returns true if `value` is different from `oldValue`.\r\n * This method is used as the default for a property's `hasChanged` function.\r\n */\n\nexport var notEqual = function notEqual(value, old) {\n  // This ensures (old==NaN, value==NaN) always returns false\n  return old !== value && (old === old || value === value);\n};\nvar defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual\n};\nvar STATE_HAS_UPDATED = 1;\nvar STATE_UPDATE_REQUESTED = 1 << 2;\nvar STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nvar STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\n/**\r\n * The Closure JS Compiler doesn't currently have good support for static\r\n * property semantics where \"this\" is dynamic (e.g.\r\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\r\n * this hack to bypass any rewriting by the compiler.\r\n */\n\nvar finalized = 'finalized';\n/**\r\n * Base element class which manages element properties and attributes. When\r\n * properties change, the `update` method is asynchronously called. This method\r\n * should be supplied by subclassers to render updates as desired.\r\n * @noInheritDoc\r\n */\n\nexport var UpdatingElement = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(UpdatingElement, _HTMLElement);\n\n  var _super = _createSuper(UpdatingElement);\n\n  function UpdatingElement() {\n    var _this;\n\n    _classCallCheck(this, UpdatingElement);\n\n    _this = _super.call(this);\n\n    _this.initialize();\n\n    return _this;\n  }\n  /**\r\n   * Returns a list of attributes corresponding to the registered properties.\r\n   * @nocollapse\r\n   */\n\n\n  _createClass(UpdatingElement, [{\n    key: \"initialize\",\n    value:\n    /**\r\n     * Performs element initialization. By default captures any pre-set values for\r\n     * registered properties.\r\n     */\n    function initialize() {\n      var _this2 = this;\n\n      this._updateState = 0;\n      this._updatePromise = new Promise(function (res) {\n        return _this2._enableUpdatingResolver = res;\n      });\n      this._changedProperties = new Map();\n\n      this._saveInstanceProperties(); // ensures first update will be caught by an early access of\n      // `updateComplete`\n\n\n      this.requestUpdateInternal();\n    }\n    /**\r\n     * Fixes any properties set on the instance before upgrade time.\r\n     * Otherwise these would shadow the accessor and break these properties.\r\n     * The properties are stored in a Map which is played back after the\r\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\r\n     * (<=41), properties created for native platform properties like (`id` or\r\n     * `name`) may not have default values set in the element constructor. On\r\n     * these browsers native properties appear on instances and therefore their\r\n     * default value will overwrite any element default (e.g. if the element sets\r\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\r\n     * the native platform default).\r\n     */\n\n  }, {\n    key: \"_saveInstanceProperties\",\n    value: function _saveInstanceProperties() {\n      var _this3 = this;\n\n      // Use forEach so this works even if for/of loops are compiled to for loops\n      // expecting arrays\n      this.constructor._classProperties.forEach(function (_v, p) {\n        if (_this3.hasOwnProperty(p)) {\n          var value = _this3[p];\n          delete _this3[p];\n\n          if (!_this3._instanceProperties) {\n            _this3._instanceProperties = new Map();\n          }\n\n          _this3._instanceProperties.set(p, value);\n        }\n      });\n    }\n    /**\r\n     * Applies previously saved instance properties.\r\n     */\n\n  }, {\n    key: \"_applyInstanceProperties\",\n    value: function _applyInstanceProperties() {\n      var _this4 = this;\n\n      // Use forEach so this works even if for/of loops are compiled to for loops\n      // expecting arrays\n      // tslint:disable-next-line:no-any\n      this._instanceProperties.forEach(function (v, p) {\n        return _this4[p] = v;\n      });\n\n      this._instanceProperties = undefined;\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      // Ensure first connection completes an update. Updates cannot complete\n      // before connection.\n      this.enableUpdating();\n    }\n  }, {\n    key: \"enableUpdating\",\n    value: function enableUpdating() {\n      if (this._enableUpdatingResolver !== undefined) {\n        this._enableUpdatingResolver();\n\n        this._enableUpdatingResolver = undefined;\n      }\n    }\n    /**\r\n     * Allows for `super.disconnectedCallback()` in extensions while\r\n     * reserving the possibility of making non-breaking feature additions\r\n     * when disconnecting at some point in the future.\r\n     */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {}\n    /**\r\n     * Synchronizes property values when attributes change.\r\n     */\n\n  }, {\n    key: \"attributeChangedCallback\",\n    value: function attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n    }\n  }, {\n    key: \"_propertyToAttribute\",\n    value: function _propertyToAttribute(name, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPropertyDeclaration;\n      var ctor = this.constructor;\n\n      var attr = ctor._attributeNameForProperty(name, options);\n\n      if (attr !== undefined) {\n        var attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.\n\n\n        if (attrValue === undefined) {\n          return;\n        } // Track if the property is being reflected to avoid\n        // setting the property again via `attributeChangedCallback`. Note:\n        // 1. this takes advantage of the fact that the callback is synchronous.\n        // 2. will behave incorrectly if multiple attributes are in the reaction\n        // stack at time of calling. However, since we process attributes\n        // in `update` this should not be possible (or an extreme corner case\n        // that we'd like to discover).\n        // mark state reflecting\n\n\n        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n\n        if (attrValue == null) {\n          this.removeAttribute(attr);\n        } else {\n          this.setAttribute(attr, attrValue);\n        } // mark state not reflecting\n\n\n        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n      }\n    }\n  }, {\n    key: \"_attributeToProperty\",\n    value: function _attributeToProperty(name, value) {\n      // Use tracking info to avoid deserializing attribute value if it was\n      // just set from a property setter.\n      if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n        return;\n      }\n\n      var ctor = this.constructor; // Note, hint this as an `AttributeMap` so closure clearly understands\n      // the type; it has issues with tracking types through statics\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n\n      var propName = ctor._attributeToPropertyMap.get(name);\n\n      if (propName !== undefined) {\n        var options = ctor.getPropertyOptions(propName); // mark state reflecting\n\n        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n        this[propName] = // tslint:disable-next-line:no-any\n        ctor._propertyValueFromAttribute(value, options); // mark state not reflecting\n\n        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n      }\n    }\n    /**\r\n     * This protected version of `requestUpdate` does not access or return the\r\n     * `updateComplete` promise. This promise can be overridden and is therefore\r\n     * not free to access.\r\n     */\n\n  }, {\n    key: \"requestUpdateInternal\",\n    value: function requestUpdateInternal(name, oldValue, options) {\n      var shouldRequestUpdate = true; // If we have a property key, perform property update steps.\n\n      if (name !== undefined) {\n        var ctor = this.constructor;\n        options = options || ctor.getPropertyOptions(name);\n\n        if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n          if (!this._changedProperties.has(name)) {\n            this._changedProperties.set(name, oldValue);\n          } // Add to reflecting properties set.\n          // Note, it's important that every change has a chance to add the\n          // property to `_reflectingProperties`. This ensures setting\n          // attribute + property reflects correctly.\n\n\n          if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\n            if (this._reflectingProperties === undefined) {\n              this._reflectingProperties = new Map();\n            }\n\n            this._reflectingProperties.set(name, options);\n          }\n        } else {\n          // Abort the request if the property should not be considered changed.\n          shouldRequestUpdate = false;\n        }\n      }\n\n      if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n        this._updatePromise = this._enqueueUpdate();\n      }\n    }\n    /**\r\n     * Requests an update which is processed asynchronously. This should\r\n     * be called when an element should update based on some state not triggered\r\n     * by setting a property. In this case, pass no arguments. It should also be\r\n     * called when manually implementing a property setter. In this case, pass the\r\n     * property `name` and `oldValue` to ensure that any configured property\r\n     * options are honored. Returns the `updateComplete` Promise which is resolved\r\n     * when the update completes.\r\n     *\r\n     * @param name {PropertyKey} (optional) name of requesting property\r\n     * @param oldValue {any} (optional) old value of requesting property\r\n     * @returns {Promise} A Promise that is resolved when the update completes.\r\n     */\n\n  }, {\n    key: \"requestUpdate\",\n    value: function requestUpdate(name, oldValue) {\n      this.requestUpdateInternal(name, oldValue);\n      return this.updateComplete;\n    }\n    /**\r\n     * Sets up the element to asynchronously update.\r\n     */\n\n  }, {\n    key: \"_enqueueUpdate\",\n    value: function () {\n      var _enqueueUpdate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\n                _context.prev = 1;\n                _context.next = 4;\n                return this._updatePromise;\n\n              case 4:\n                _context.next = 8;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](1);\n\n              case 8:\n                result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to\n                // enable coordinating updates with a scheduler. Note, the result is\n                // checked to avoid delaying an additional microtask unless we need to.\n\n                if (!(result != null)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 12;\n                return result;\n\n              case 12:\n                return _context.abrupt(\"return\", !this._hasRequestedUpdate);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 6]]);\n      }));\n\n      function _enqueueUpdate() {\n        return _enqueueUpdate2.apply(this, arguments);\n      }\n\n      return _enqueueUpdate;\n    }()\n  }, {\n    key: \"_hasRequestedUpdate\",\n    get: function get() {\n      return this._updateState & STATE_UPDATE_REQUESTED;\n    }\n  }, {\n    key: \"hasUpdated\",\n    get: function get() {\n      return this._updateState & STATE_HAS_UPDATED;\n    }\n    /**\r\n     * Performs an element update. Note, if an exception is thrown during the\r\n     * update, `firstUpdated` and `updated` will not be called.\r\n     *\r\n     * You can override this method to change the timing of updates. If this\r\n     * method is overridden, `super.performUpdate()` must be called.\r\n     *\r\n     * For instance, to schedule updates to occur just before the next frame:\r\n     *\r\n     * ```\r\n     * protected async performUpdate(): Promise<unknown> {\r\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\r\n     *   super.performUpdate();\r\n     * }\r\n     * ```\r\n     */\n\n  }, {\n    key: \"performUpdate\",\n    value: function performUpdate() {\n      // Abort any update if one is not pending when this is called.\n      // This can happen if `performUpdate` is called early to \"flush\"\n      // the update.\n      if (!this._hasRequestedUpdate) {\n        return;\n      } // Mixin instance properties once, if they exist.\n\n\n      if (this._instanceProperties) {\n        this._applyInstanceProperties();\n      }\n\n      var shouldUpdate = false;\n      var changedProperties = this._changedProperties;\n\n      try {\n        shouldUpdate = this.shouldUpdate(changedProperties);\n\n        if (shouldUpdate) {\n          this.update(changedProperties);\n        } else {\n          this._markUpdated();\n        }\n      } catch (e) {\n        // Prevent `firstUpdated` and `updated` from running when there's an\n        // update exception.\n        shouldUpdate = false; // Ensure element can accept additional updates after an exception.\n\n        this._markUpdated();\n\n        throw e;\n      }\n\n      if (shouldUpdate) {\n        if (!(this._updateState & STATE_HAS_UPDATED)) {\n          this._updateState = this._updateState | STATE_HAS_UPDATED;\n          this.firstUpdated(changedProperties);\n        }\n\n        this.updated(changedProperties);\n      }\n    }\n  }, {\n    key: \"_markUpdated\",\n    value: function _markUpdated() {\n      this._changedProperties = new Map();\n      this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n    }\n    /**\r\n     * Returns a Promise that resolves when the element has completed updating.\r\n     * The Promise value is a boolean that is `true` if the element completed the\r\n     * update without triggering another update. The Promise result is `false` if\r\n     * a property was set inside `updated()`. If the Promise is rejected, an\r\n     * exception was thrown during the update.\r\n     *\r\n     * To await additional asynchronous work, override the `_getUpdateComplete`\r\n     * method. For example, it is sometimes useful to await a rendered element\r\n     * before fulfilling this Promise. To do this, first await\r\n     * `super._getUpdateComplete()`, then any subsequent state.\r\n     *\r\n     * @returns {Promise} The Promise returns a boolean that indicates if the\r\n     * update resolved without triggering another update.\r\n     */\n\n  }, {\n    key: \"updateComplete\",\n    get: function get() {\n      return this._getUpdateComplete();\n    }\n    /**\r\n     * Override point for the `updateComplete` promise.\r\n     *\r\n     * It is not safe to override the `updateComplete` getter directly due to a\r\n     * limitation in TypeScript which means it is not possible to call a\r\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\r\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\r\n     * This method should be overridden instead. For example:\r\n     *\r\n     *   class MyElement extends LitElement {\r\n     *     async _getUpdateComplete() {\r\n     *       await super._getUpdateComplete();\r\n     *       await this._myChild.updateComplete;\r\n     *     }\r\n     *   }\r\n     */\n\n  }, {\n    key: \"_getUpdateComplete\",\n    value: function _getUpdateComplete() {\n      return this._updatePromise;\n    }\n    /**\r\n     * Controls whether or not `update` should be called when the element requests\r\n     * an update. By default, this method always returns `true`, but this can be\r\n     * customized to control when to update.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\n\n  }, {\n    key: \"shouldUpdate\",\n    value: function shouldUpdate(_changedProperties) {\n      return true;\n    }\n    /**\r\n     * Updates the element. This method reflects property values to attributes.\r\n     * It can be overridden to render and keep updated element DOM.\r\n     * Setting properties inside this method will *not* trigger\r\n     * another update.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(_changedProperties) {\n      var _this5 = this;\n\n      if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {\n        // Use forEach so this works even if for/of loops are compiled to for\n        // loops expecting arrays\n        this._reflectingProperties.forEach(function (v, k) {\n          return _this5._propertyToAttribute(k, _this5[k], v);\n        });\n\n        this._reflectingProperties = undefined;\n      }\n\n      this._markUpdated();\n    }\n    /**\r\n     * Invoked whenever the element is updated. Implement to perform\r\n     * post-updating tasks via DOM APIs, for example, focusing an element.\r\n     *\r\n     * Setting properties inside this method will trigger the element to update\r\n     * again after this update cycle completes.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\n\n  }, {\n    key: \"updated\",\n    value: function updated(_changedProperties) {}\n    /**\r\n     * Invoked when the element is first updated. Implement to perform one time\r\n     * work on the element after update.\r\n     *\r\n     * Setting properties inside this method will trigger the element to update\r\n     * again after this update cycle completes.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\n\n  }, {\n    key: \"firstUpdated\",\n    value: function firstUpdated(_changedProperties) {}\n  }], [{\n    key: \"observedAttributes\",\n    get: function get() {\n      var _this6 = this;\n\n      // note: piggy backing on this to ensure we're finalized.\n      this.finalize();\n      var attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops\n      // expecting arrays\n\n      this._classProperties.forEach(function (v, p) {\n        var attr = _this6._attributeNameForProperty(p, v);\n\n        if (attr !== undefined) {\n          _this6._attributeToPropertyMap.set(attr, p);\n\n          attributes.push(attr);\n        }\n      });\n\n      return attributes;\n    }\n    /**\r\n     * Ensures the private `_classProperties` property metadata is created.\r\n     * In addition to `finalize` this is also called in `createProperty` to\r\n     * ensure the `@property` decorator can add property metadata.\r\n     */\n\n    /** @nocollapse */\n\n  }, {\n    key: \"_ensureClassProperties\",\n    value: function _ensureClassProperties() {\n      var _this7 = this;\n\n      // ensure private storage for property declarations.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {\n        this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.\n\n        var superProperties = Object.getPrototypeOf(this)._classProperties;\n\n        if (superProperties !== undefined) {\n          superProperties.forEach(function (v, k) {\n            return _this7._classProperties.set(k, v);\n          });\n        }\n      }\n    }\n    /**\r\n     * Creates a property accessor on the element prototype if one does not exist\r\n     * and stores a PropertyDeclaration for the property with the given options.\r\n     * The property setter calls the property's `hasChanged` property option\r\n     * or uses a strict identity check to determine whether or not to request\r\n     * an update.\r\n     *\r\n     * This method may be overridden to customize properties; however,\r\n     * when doing so, it's important to call `super.createProperty` to ensure\r\n     * the property is setup correctly. This method calls\r\n     * `getPropertyDescriptor` internally to get a descriptor to install.\r\n     * To customize what properties do when they are get or set, override\r\n     * `getPropertyDescriptor`. To customize the options for a property,\r\n     * implement `createProperty` like this:\r\n     *\r\n     * static createProperty(name, options) {\r\n     *   options = Object.assign(options, {myOption: true});\r\n     *   super.createProperty(name, options);\r\n     * }\r\n     *\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"createProperty\",\n    value: function createProperty(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultPropertyDeclaration;\n\n      // Note, since this can be called by the `@property` decorator which\n      // is called before `finalize`, we ensure storage exists for property\n      // metadata.\n      this._ensureClassProperties();\n\n      this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since\n      // it would be lost otherwise and that would never be the user's intention;\n      // Instead, we expect users to call `requestUpdate` themselves from\n      // user-defined accessors. Note that if the super has an accessor we will\n      // still overwrite it\n\n\n      if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n        return;\n      }\n\n      var key = typeof name === 'symbol' ? Symbol() : \"__\".concat(name);\n      var descriptor = this.getPropertyDescriptor(name, key, options);\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(this.prototype, name, descriptor);\n      }\n    }\n    /**\r\n     * Returns a property descriptor to be defined on the given named property.\r\n     * If no descriptor is returned, the property will not become an accessor.\r\n     * For example,\r\n     *\r\n     *   class MyElement extends LitElement {\r\n     *     static getPropertyDescriptor(name, key, options) {\r\n     *       const defaultDescriptor =\r\n     *           super.getPropertyDescriptor(name, key, options);\r\n     *       const setter = defaultDescriptor.set;\r\n     *       return {\r\n     *         get: defaultDescriptor.get,\r\n     *         set(value) {\r\n     *           setter.call(this, value);\r\n     *           // custom action.\r\n     *         },\r\n     *         configurable: true,\r\n     *         enumerable: true\r\n     *       }\r\n     *     }\r\n     *   }\r\n     *\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"getPropertyDescriptor\",\n    value: function getPropertyDescriptor(name, key, options) {\n      return {\n        // tslint:disable-next-line:no-any no symbol in index\n        get: function get() {\n          return this[key];\n        },\n        set: function set(value) {\n          var oldValue = this[name];\n          this[key] = value;\n          this.requestUpdateInternal(name, oldValue, options);\n        },\n        configurable: true,\n        enumerable: true\n      };\n    }\n    /**\r\n     * Returns the property options associated with the given property.\r\n     * These options are defined with a PropertyDeclaration via the `properties`\r\n     * object or the `@property` decorator and are registered in\r\n     * `createProperty(...)`.\r\n     *\r\n     * Note, this method should be considered \"final\" and not overridden. To\r\n     * customize the options for a given property, override `createProperty`.\r\n     *\r\n     * @nocollapse\r\n     * @final\r\n     */\n\n  }, {\n    key: \"getPropertyOptions\",\n    value: function getPropertyOptions(name) {\n      return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;\n    }\n    /**\r\n     * Creates property accessors for registered properties and ensures\r\n     * any superclasses are also finalized.\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      // finalize any superclasses\n      var superCtor = Object.getPrototypeOf(this);\n\n      if (!superCtor.hasOwnProperty(finalized)) {\n        superCtor.finalize();\n      }\n\n      this[finalized] = true;\n\n      this._ensureClassProperties(); // initialize Map populated in observedAttributes\n\n\n      this._attributeToPropertyMap = new Map(); // make any properties\n      // Note, only process \"own\" properties since this element will inherit\n      // any properties defined on the superClass, and finalization ensures\n      // the entire prototype chain is finalized.\n\n      if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n        var props = this.properties; // support symbols in properties (IE11 does not support this)\n\n        var propKeys = [].concat(_toConsumableArray(Object.getOwnPropertyNames(props)), _toConsumableArray(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])); // This for/of is ok because propKeys is an array\n\n        var _iterator = _createForOfIteratorHelper(propKeys),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var p = _step.value;\n            // note, use of `any` is due to TypeSript lack of support for symbol in\n            // index types\n            // tslint:disable-next-line:no-any no symbol in index\n            this.createProperty(p, props[p]);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\r\n     * Returns the property name for the given attribute `name`.\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"_attributeNameForProperty\",\n    value: function _attributeNameForProperty(name, options) {\n      var attribute = options.attribute;\n      return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;\n    }\n    /**\r\n     * Returns true if a property should request an update.\r\n     * Called when a property value is set and uses the `hasChanged`\r\n     * option for the property if present or a strict identity check.\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"_valueHasChanged\",\n    value: function _valueHasChanged(value, old) {\n      var hasChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : notEqual;\n      return hasChanged(value, old);\n    }\n    /**\r\n     * Returns the property value for the given attribute value.\r\n     * Called via the `attributeChangedCallback` and uses the property's\r\n     * `converter` or `converter.fromAttribute` property option.\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"_propertyValueFromAttribute\",\n    value: function _propertyValueFromAttribute(value, options) {\n      var type = options.type;\n      var converter = options.converter || defaultConverter;\n      var fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;\n      return fromAttribute ? fromAttribute(value, type) : value;\n    }\n    /**\r\n     * Returns the attribute value for the given property value. If this\r\n     * returns undefined, the property will *not* be reflected to an attribute.\r\n     * If this returns null, the attribute will be removed, otherwise the\r\n     * attribute will be set to the value.\r\n     * This uses the property's `reflect` and `type.toAttribute` property options.\r\n     * @nocollapse\r\n     */\n\n  }, {\n    key: \"_propertyValueToAttribute\",\n    value: function _propertyValueToAttribute(value, options) {\n      if (options.reflect === undefined) {\n        return;\n      }\n\n      var type = options.type;\n      var converter = options.converter;\n      var toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;\n      return toAttribute(value, type);\n    }\n  }]);\n\n  return UpdatingElement;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n_a = finalized;\n/**\r\n * Marks class as having finished creating properties.\r\n */\n\nUpdatingElement[_a] = true; //# sourceMappingURL=updating-element.js.map","map":{"version":3,"sources":["C:/Users/HP/Desktop/CNS-Portal-ashwini15523/frontend/angular-ui/node_modules/lit-element/lib/updating-element.js"],"names":["_a","window","JSCompiler_renameProperty","prop","_obj","defaultConverter","toAttribute","value","type","Boolean","Object","Array","JSON","stringify","fromAttribute","Number","parse","notEqual","old","defaultPropertyDeclaration","attribute","String","converter","reflect","hasChanged","STATE_HAS_UPDATED","STATE_UPDATE_REQUESTED","STATE_IS_REFLECTING_TO_ATTRIBUTE","STATE_IS_REFLECTING_TO_PROPERTY","finalized","UpdatingElement","initialize","_updateState","_updatePromise","Promise","res","_enableUpdatingResolver","_changedProperties","Map","_saveInstanceProperties","requestUpdateInternal","constructor","_classProperties","forEach","_v","p","hasOwnProperty","_instanceProperties","set","v","undefined","enableUpdating","name","_attributeToProperty","options","ctor","attr","_attributeNameForProperty","attrValue","_propertyValueToAttribute","removeAttribute","setAttribute","propName","_attributeToPropertyMap","get","getPropertyOptions","_propertyValueFromAttribute","oldValue","shouldRequestUpdate","_valueHasChanged","has","_reflectingProperties","_hasRequestedUpdate","_enqueueUpdate","updateComplete","result","performUpdate","_applyInstanceProperties","shouldUpdate","changedProperties","update","_markUpdated","e","firstUpdated","updated","_getUpdateComplete","size","k","_propertyToAttribute","finalize","attributes","push","superProperties","getPrototypeOf","_ensureClassProperties","noAccessor","prototype","key","Symbol","descriptor","getPropertyDescriptor","defineProperty","configurable","enumerable","superCtor","props","properties","propKeys","getOwnPropertyNames","getOwnPropertySymbols","createProperty","toLowerCase","HTMLElement"],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nvar _a;\r\n/**\r\n * Use this module if you want to create your own base class extending\r\n * [[UpdatingElement]].\r\n * @packageDocumentation\r\n */\r\n/*\r\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\r\n * replaced at compile time by the munged name for object[property]. We cannot\r\n * alias this function, so we have to use a small shim that has the same\r\n * behavior when not compiling.\r\n */\r\nwindow.JSCompiler_renameProperty =\r\n    (prop, _obj) => prop;\r\nexport const defaultConverter = {\r\n    toAttribute(value, type) {\r\n        switch (type) {\r\n            case Boolean:\r\n                return value ? '' : null;\r\n            case Object:\r\n            case Array:\r\n                // if the value is `null` or `undefined` pass this through\r\n                // to allow removing/no change behavior.\r\n                return value == null ? value : JSON.stringify(value);\r\n        }\r\n        return value;\r\n    },\r\n    fromAttribute(value, type) {\r\n        switch (type) {\r\n            case Boolean:\r\n                return value !== null;\r\n            case Number:\r\n                return value === null ? null : Number(value);\r\n            case Object:\r\n            case Array:\r\n                return JSON.parse(value);\r\n        }\r\n        return value;\r\n    }\r\n};\r\n/**\r\n * Change function that returns true if `value` is different from `oldValue`.\r\n * This method is used as the default for a property's `hasChanged` function.\r\n */\r\nexport const notEqual = (value, old) => {\r\n    // This ensures (old==NaN, value==NaN) always returns false\r\n    return old !== value && (old === old || value === value);\r\n};\r\nconst defaultPropertyDeclaration = {\r\n    attribute: true,\r\n    type: String,\r\n    converter: defaultConverter,\r\n    reflect: false,\r\n    hasChanged: notEqual\r\n};\r\nconst STATE_HAS_UPDATED = 1;\r\nconst STATE_UPDATE_REQUESTED = 1 << 2;\r\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\r\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\r\n/**\r\n * The Closure JS Compiler doesn't currently have good support for static\r\n * property semantics where \"this\" is dynamic (e.g.\r\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\r\n * this hack to bypass any rewriting by the compiler.\r\n */\r\nconst finalized = 'finalized';\r\n/**\r\n * Base element class which manages element properties and attributes. When\r\n * properties change, the `update` method is asynchronously called. This method\r\n * should be supplied by subclassers to render updates as desired.\r\n * @noInheritDoc\r\n */\r\nexport class UpdatingElement extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this.initialize();\r\n    }\r\n    /**\r\n     * Returns a list of attributes corresponding to the registered properties.\r\n     * @nocollapse\r\n     */\r\n    static get observedAttributes() {\r\n        // note: piggy backing on this to ensure we're finalized.\r\n        this.finalize();\r\n        const attributes = [];\r\n        // Use forEach so this works even if for/of loops are compiled to for loops\r\n        // expecting arrays\r\n        this._classProperties.forEach((v, p) => {\r\n            const attr = this._attributeNameForProperty(p, v);\r\n            if (attr !== undefined) {\r\n                this._attributeToPropertyMap.set(attr, p);\r\n                attributes.push(attr);\r\n            }\r\n        });\r\n        return attributes;\r\n    }\r\n    /**\r\n     * Ensures the private `_classProperties` property metadata is created.\r\n     * In addition to `finalize` this is also called in `createProperty` to\r\n     * ensure the `@property` decorator can add property metadata.\r\n     */\r\n    /** @nocollapse */\r\n    static _ensureClassProperties() {\r\n        // ensure private storage for property declarations.\r\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {\r\n            this._classProperties = new Map();\r\n            // NOTE: Workaround IE11 not supporting Map constructor argument.\r\n            const superProperties = Object.getPrototypeOf(this)._classProperties;\r\n            if (superProperties !== undefined) {\r\n                superProperties.forEach((v, k) => this._classProperties.set(k, v));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates a property accessor on the element prototype if one does not exist\r\n     * and stores a PropertyDeclaration for the property with the given options.\r\n     * The property setter calls the property's `hasChanged` property option\r\n     * or uses a strict identity check to determine whether or not to request\r\n     * an update.\r\n     *\r\n     * This method may be overridden to customize properties; however,\r\n     * when doing so, it's important to call `super.createProperty` to ensure\r\n     * the property is setup correctly. This method calls\r\n     * `getPropertyDescriptor` internally to get a descriptor to install.\r\n     * To customize what properties do when they are get or set, override\r\n     * `getPropertyDescriptor`. To customize the options for a property,\r\n     * implement `createProperty` like this:\r\n     *\r\n     * static createProperty(name, options) {\r\n     *   options = Object.assign(options, {myOption: true});\r\n     *   super.createProperty(name, options);\r\n     * }\r\n     *\r\n     * @nocollapse\r\n     */\r\n    static createProperty(name, options = defaultPropertyDeclaration) {\r\n        // Note, since this can be called by the `@property` decorator which\r\n        // is called before `finalize`, we ensure storage exists for property\r\n        // metadata.\r\n        this._ensureClassProperties();\r\n        this._classProperties.set(name, options);\r\n        // Do not generate an accessor if the prototype already has one, since\r\n        // it would be lost otherwise and that would never be the user's intention;\r\n        // Instead, we expect users to call `requestUpdate` themselves from\r\n        // user-defined accessors. Note that if the super has an accessor we will\r\n        // still overwrite it\r\n        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\r\n            return;\r\n        }\r\n        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\r\n        const descriptor = this.getPropertyDescriptor(name, key, options);\r\n        if (descriptor !== undefined) {\r\n            Object.defineProperty(this.prototype, name, descriptor);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a property descriptor to be defined on the given named property.\r\n     * If no descriptor is returned, the property will not become an accessor.\r\n     * For example,\r\n     *\r\n     *   class MyElement extends LitElement {\r\n     *     static getPropertyDescriptor(name, key, options) {\r\n     *       const defaultDescriptor =\r\n     *           super.getPropertyDescriptor(name, key, options);\r\n     *       const setter = defaultDescriptor.set;\r\n     *       return {\r\n     *         get: defaultDescriptor.get,\r\n     *         set(value) {\r\n     *           setter.call(this, value);\r\n     *           // custom action.\r\n     *         },\r\n     *         configurable: true,\r\n     *         enumerable: true\r\n     *       }\r\n     *     }\r\n     *   }\r\n     *\r\n     * @nocollapse\r\n     */\r\n    static getPropertyDescriptor(name, key, options) {\r\n        return {\r\n            // tslint:disable-next-line:no-any no symbol in index\r\n            get() {\r\n                return this[key];\r\n            },\r\n            set(value) {\r\n                const oldValue = this[name];\r\n                this[key] = value;\r\n                this\r\n                    .requestUpdateInternal(name, oldValue, options);\r\n            },\r\n            configurable: true,\r\n            enumerable: true\r\n        };\r\n    }\r\n    /**\r\n     * Returns the property options associated with the given property.\r\n     * These options are defined with a PropertyDeclaration via the `properties`\r\n     * object or the `@property` decorator and are registered in\r\n     * `createProperty(...)`.\r\n     *\r\n     * Note, this method should be considered \"final\" and not overridden. To\r\n     * customize the options for a given property, override `createProperty`.\r\n     *\r\n     * @nocollapse\r\n     * @final\r\n     */\r\n    static getPropertyOptions(name) {\r\n        return this._classProperties && this._classProperties.get(name) ||\r\n            defaultPropertyDeclaration;\r\n    }\r\n    /**\r\n     * Creates property accessors for registered properties and ensures\r\n     * any superclasses are also finalized.\r\n     * @nocollapse\r\n     */\r\n    static finalize() {\r\n        // finalize any superclasses\r\n        const superCtor = Object.getPrototypeOf(this);\r\n        if (!superCtor.hasOwnProperty(finalized)) {\r\n            superCtor.finalize();\r\n        }\r\n        this[finalized] = true;\r\n        this._ensureClassProperties();\r\n        // initialize Map populated in observedAttributes\r\n        this._attributeToPropertyMap = new Map();\r\n        // make any properties\r\n        // Note, only process \"own\" properties since this element will inherit\r\n        // any properties defined on the superClass, and finalization ensures\r\n        // the entire prototype chain is finalized.\r\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\r\n            const props = this.properties;\r\n            // support symbols in properties (IE11 does not support this)\r\n            const propKeys = [\r\n                ...Object.getOwnPropertyNames(props),\r\n                ...(typeof Object.getOwnPropertySymbols === 'function') ?\r\n                    Object.getOwnPropertySymbols(props) :\r\n                    []\r\n            ];\r\n            // This for/of is ok because propKeys is an array\r\n            for (const p of propKeys) {\r\n                // note, use of `any` is due to TypeSript lack of support for symbol in\r\n                // index types\r\n                // tslint:disable-next-line:no-any no symbol in index\r\n                this.createProperty(p, props[p]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the property name for the given attribute `name`.\r\n     * @nocollapse\r\n     */\r\n    static _attributeNameForProperty(name, options) {\r\n        const attribute = options.attribute;\r\n        return attribute === false ?\r\n            undefined :\r\n            (typeof attribute === 'string' ?\r\n                attribute :\r\n                (typeof name === 'string' ? name.toLowerCase() : undefined));\r\n    }\r\n    /**\r\n     * Returns true if a property should request an update.\r\n     * Called when a property value is set and uses the `hasChanged`\r\n     * option for the property if present or a strict identity check.\r\n     * @nocollapse\r\n     */\r\n    static _valueHasChanged(value, old, hasChanged = notEqual) {\r\n        return hasChanged(value, old);\r\n    }\r\n    /**\r\n     * Returns the property value for the given attribute value.\r\n     * Called via the `attributeChangedCallback` and uses the property's\r\n     * `converter` or `converter.fromAttribute` property option.\r\n     * @nocollapse\r\n     */\r\n    static _propertyValueFromAttribute(value, options) {\r\n        const type = options.type;\r\n        const converter = options.converter || defaultConverter;\r\n        const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);\r\n        return fromAttribute ? fromAttribute(value, type) : value;\r\n    }\r\n    /**\r\n     * Returns the attribute value for the given property value. If this\r\n     * returns undefined, the property will *not* be reflected to an attribute.\r\n     * If this returns null, the attribute will be removed, otherwise the\r\n     * attribute will be set to the value.\r\n     * This uses the property's `reflect` and `type.toAttribute` property options.\r\n     * @nocollapse\r\n     */\r\n    static _propertyValueToAttribute(value, options) {\r\n        if (options.reflect === undefined) {\r\n            return;\r\n        }\r\n        const type = options.type;\r\n        const converter = options.converter;\r\n        const toAttribute = converter && converter.toAttribute ||\r\n            defaultConverter.toAttribute;\r\n        return toAttribute(value, type);\r\n    }\r\n    /**\r\n     * Performs element initialization. By default captures any pre-set values for\r\n     * registered properties.\r\n     */\r\n    initialize() {\r\n        this._updateState = 0;\r\n        this._updatePromise =\r\n            new Promise((res) => this._enableUpdatingResolver = res);\r\n        this._changedProperties = new Map();\r\n        this._saveInstanceProperties();\r\n        // ensures first update will be caught by an early access of\r\n        // `updateComplete`\r\n        this.requestUpdateInternal();\r\n    }\r\n    /**\r\n     * Fixes any properties set on the instance before upgrade time.\r\n     * Otherwise these would shadow the accessor and break these properties.\r\n     * The properties are stored in a Map which is played back after the\r\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\r\n     * (<=41), properties created for native platform properties like (`id` or\r\n     * `name`) may not have default values set in the element constructor. On\r\n     * these browsers native properties appear on instances and therefore their\r\n     * default value will overwrite any element default (e.g. if the element sets\r\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\r\n     * the native platform default).\r\n     */\r\n    _saveInstanceProperties() {\r\n        // Use forEach so this works even if for/of loops are compiled to for loops\r\n        // expecting arrays\r\n        this.constructor\r\n            ._classProperties.forEach((_v, p) => {\r\n            if (this.hasOwnProperty(p)) {\r\n                const value = this[p];\r\n                delete this[p];\r\n                if (!this._instanceProperties) {\r\n                    this._instanceProperties = new Map();\r\n                }\r\n                this._instanceProperties.set(p, value);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Applies previously saved instance properties.\r\n     */\r\n    _applyInstanceProperties() {\r\n        // Use forEach so this works even if for/of loops are compiled to for loops\r\n        // expecting arrays\r\n        // tslint:disable-next-line:no-any\r\n        this._instanceProperties.forEach((v, p) => this[p] = v);\r\n        this._instanceProperties = undefined;\r\n    }\r\n    connectedCallback() {\r\n        // Ensure first connection completes an update. Updates cannot complete\r\n        // before connection.\r\n        this.enableUpdating();\r\n    }\r\n    enableUpdating() {\r\n        if (this._enableUpdatingResolver !== undefined) {\r\n            this._enableUpdatingResolver();\r\n            this._enableUpdatingResolver = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Allows for `super.disconnectedCallback()` in extensions while\r\n     * reserving the possibility of making non-breaking feature additions\r\n     * when disconnecting at some point in the future.\r\n     */\r\n    disconnectedCallback() {\r\n    }\r\n    /**\r\n     * Synchronizes property values when attributes change.\r\n     */\r\n    attributeChangedCallback(name, old, value) {\r\n        if (old !== value) {\r\n            this._attributeToProperty(name, value);\r\n        }\r\n    }\r\n    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\r\n        const ctor = this.constructor;\r\n        const attr = ctor._attributeNameForProperty(name, options);\r\n        if (attr !== undefined) {\r\n            const attrValue = ctor._propertyValueToAttribute(value, options);\r\n            // an undefined value does not change the attribute.\r\n            if (attrValue === undefined) {\r\n                return;\r\n            }\r\n            // Track if the property is being reflected to avoid\r\n            // setting the property again via `attributeChangedCallback`. Note:\r\n            // 1. this takes advantage of the fact that the callback is synchronous.\r\n            // 2. will behave incorrectly if multiple attributes are in the reaction\r\n            // stack at time of calling. However, since we process attributes\r\n            // in `update` this should not be possible (or an extreme corner case\r\n            // that we'd like to discover).\r\n            // mark state reflecting\r\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\r\n            if (attrValue == null) {\r\n                this.removeAttribute(attr);\r\n            }\r\n            else {\r\n                this.setAttribute(attr, attrValue);\r\n            }\r\n            // mark state not reflecting\r\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\r\n        }\r\n    }\r\n    _attributeToProperty(name, value) {\r\n        // Use tracking info to avoid deserializing attribute value if it was\r\n        // just set from a property setter.\r\n        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\r\n            return;\r\n        }\r\n        const ctor = this.constructor;\r\n        // Note, hint this as an `AttributeMap` so closure clearly understands\r\n        // the type; it has issues with tracking types through statics\r\n        // tslint:disable-next-line:no-unnecessary-type-assertion\r\n        const propName = ctor._attributeToPropertyMap.get(name);\r\n        if (propName !== undefined) {\r\n            const options = ctor.getPropertyOptions(propName);\r\n            // mark state reflecting\r\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\r\n            this[propName] =\r\n                // tslint:disable-next-line:no-any\r\n                ctor._propertyValueFromAttribute(value, options);\r\n            // mark state not reflecting\r\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\r\n        }\r\n    }\r\n    /**\r\n     * This protected version of `requestUpdate` does not access or return the\r\n     * `updateComplete` promise. This promise can be overridden and is therefore\r\n     * not free to access.\r\n     */\r\n    requestUpdateInternal(name, oldValue, options) {\r\n        let shouldRequestUpdate = true;\r\n        // If we have a property key, perform property update steps.\r\n        if (name !== undefined) {\r\n            const ctor = this.constructor;\r\n            options = options || ctor.getPropertyOptions(name);\r\n            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\r\n                if (!this._changedProperties.has(name)) {\r\n                    this._changedProperties.set(name, oldValue);\r\n                }\r\n                // Add to reflecting properties set.\r\n                // Note, it's important that every change has a chance to add the\r\n                // property to `_reflectingProperties`. This ensures setting\r\n                // attribute + property reflects correctly.\r\n                if (options.reflect === true &&\r\n                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\r\n                    if (this._reflectingProperties === undefined) {\r\n                        this._reflectingProperties = new Map();\r\n                    }\r\n                    this._reflectingProperties.set(name, options);\r\n                }\r\n            }\r\n            else {\r\n                // Abort the request if the property should not be considered changed.\r\n                shouldRequestUpdate = false;\r\n            }\r\n        }\r\n        if (!this._hasRequestedUpdate && shouldRequestUpdate) {\r\n            this._updatePromise = this._enqueueUpdate();\r\n        }\r\n    }\r\n    /**\r\n     * Requests an update which is processed asynchronously. This should\r\n     * be called when an element should update based on some state not triggered\r\n     * by setting a property. In this case, pass no arguments. It should also be\r\n     * called when manually implementing a property setter. In this case, pass the\r\n     * property `name` and `oldValue` to ensure that any configured property\r\n     * options are honored. Returns the `updateComplete` Promise which is resolved\r\n     * when the update completes.\r\n     *\r\n     * @param name {PropertyKey} (optional) name of requesting property\r\n     * @param oldValue {any} (optional) old value of requesting property\r\n     * @returns {Promise} A Promise that is resolved when the update completes.\r\n     */\r\n    requestUpdate(name, oldValue) {\r\n        this.requestUpdateInternal(name, oldValue);\r\n        return this.updateComplete;\r\n    }\r\n    /**\r\n     * Sets up the element to asynchronously update.\r\n     */\r\n    async _enqueueUpdate() {\r\n        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\r\n        try {\r\n            // Ensure any previous update has resolved before updating.\r\n            // This `await` also ensures that property changes are batched.\r\n            await this._updatePromise;\r\n        }\r\n        catch (e) {\r\n            // Ignore any previous errors. We only care that the previous cycle is\r\n            // done. Any error should have been handled in the previous update.\r\n        }\r\n        const result = this.performUpdate();\r\n        // If `performUpdate` returns a Promise, we await it. This is done to\r\n        // enable coordinating updates with a scheduler. Note, the result is\r\n        // checked to avoid delaying an additional microtask unless we need to.\r\n        if (result != null) {\r\n            await result;\r\n        }\r\n        return !this._hasRequestedUpdate;\r\n    }\r\n    get _hasRequestedUpdate() {\r\n        return (this._updateState & STATE_UPDATE_REQUESTED);\r\n    }\r\n    get hasUpdated() {\r\n        return (this._updateState & STATE_HAS_UPDATED);\r\n    }\r\n    /**\r\n     * Performs an element update. Note, if an exception is thrown during the\r\n     * update, `firstUpdated` and `updated` will not be called.\r\n     *\r\n     * You can override this method to change the timing of updates. If this\r\n     * method is overridden, `super.performUpdate()` must be called.\r\n     *\r\n     * For instance, to schedule updates to occur just before the next frame:\r\n     *\r\n     * ```\r\n     * protected async performUpdate(): Promise<unknown> {\r\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\r\n     *   super.performUpdate();\r\n     * }\r\n     * ```\r\n     */\r\n    performUpdate() {\r\n        // Abort any update if one is not pending when this is called.\r\n        // This can happen if `performUpdate` is called early to \"flush\"\r\n        // the update.\r\n        if (!this._hasRequestedUpdate) {\r\n            return;\r\n        }\r\n        // Mixin instance properties once, if they exist.\r\n        if (this._instanceProperties) {\r\n            this._applyInstanceProperties();\r\n        }\r\n        let shouldUpdate = false;\r\n        const changedProperties = this._changedProperties;\r\n        try {\r\n            shouldUpdate = this.shouldUpdate(changedProperties);\r\n            if (shouldUpdate) {\r\n                this.update(changedProperties);\r\n            }\r\n            else {\r\n                this._markUpdated();\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Prevent `firstUpdated` and `updated` from running when there's an\r\n            // update exception.\r\n            shouldUpdate = false;\r\n            // Ensure element can accept additional updates after an exception.\r\n            this._markUpdated();\r\n            throw e;\r\n        }\r\n        if (shouldUpdate) {\r\n            if (!(this._updateState & STATE_HAS_UPDATED)) {\r\n                this._updateState = this._updateState | STATE_HAS_UPDATED;\r\n                this.firstUpdated(changedProperties);\r\n            }\r\n            this.updated(changedProperties);\r\n        }\r\n    }\r\n    _markUpdated() {\r\n        this._changedProperties = new Map();\r\n        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\r\n    }\r\n    /**\r\n     * Returns a Promise that resolves when the element has completed updating.\r\n     * The Promise value is a boolean that is `true` if the element completed the\r\n     * update without triggering another update. The Promise result is `false` if\r\n     * a property was set inside `updated()`. If the Promise is rejected, an\r\n     * exception was thrown during the update.\r\n     *\r\n     * To await additional asynchronous work, override the `_getUpdateComplete`\r\n     * method. For example, it is sometimes useful to await a rendered element\r\n     * before fulfilling this Promise. To do this, first await\r\n     * `super._getUpdateComplete()`, then any subsequent state.\r\n     *\r\n     * @returns {Promise} The Promise returns a boolean that indicates if the\r\n     * update resolved without triggering another update.\r\n     */\r\n    get updateComplete() {\r\n        return this._getUpdateComplete();\r\n    }\r\n    /**\r\n     * Override point for the `updateComplete` promise.\r\n     *\r\n     * It is not safe to override the `updateComplete` getter directly due to a\r\n     * limitation in TypeScript which means it is not possible to call a\r\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\r\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\r\n     * This method should be overridden instead. For example:\r\n     *\r\n     *   class MyElement extends LitElement {\r\n     *     async _getUpdateComplete() {\r\n     *       await super._getUpdateComplete();\r\n     *       await this._myChild.updateComplete;\r\n     *     }\r\n     *   }\r\n     */\r\n    _getUpdateComplete() {\r\n        return this._updatePromise;\r\n    }\r\n    /**\r\n     * Controls whether or not `update` should be called when the element requests\r\n     * an update. By default, this method always returns `true`, but this can be\r\n     * customized to control when to update.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\r\n    shouldUpdate(_changedProperties) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Updates the element. This method reflects property values to attributes.\r\n     * It can be overridden to render and keep updated element DOM.\r\n     * Setting properties inside this method will *not* trigger\r\n     * another update.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\r\n    update(_changedProperties) {\r\n        if (this._reflectingProperties !== undefined &&\r\n            this._reflectingProperties.size > 0) {\r\n            // Use forEach so this works even if for/of loops are compiled to for\r\n            // loops expecting arrays\r\n            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));\r\n            this._reflectingProperties = undefined;\r\n        }\r\n        this._markUpdated();\r\n    }\r\n    /**\r\n     * Invoked whenever the element is updated. Implement to perform\r\n     * post-updating tasks via DOM APIs, for example, focusing an element.\r\n     *\r\n     * Setting properties inside this method will trigger the element to update\r\n     * again after this update cycle completes.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\r\n    updated(_changedProperties) {\r\n    }\r\n    /**\r\n     * Invoked when the element is first updated. Implement to perform one time\r\n     * work on the element after update.\r\n     *\r\n     * Setting properties inside this method will trigger the element to update\r\n     * again after this update cycle completes.\r\n     *\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\r\n    firstUpdated(_changedProperties) {\r\n    }\r\n}\r\n_a = finalized;\r\n/**\r\n * Marks class as having finished creating properties.\r\n */\r\nUpdatingElement[_a] = true;\r\n//# sourceMappingURL=updating-element.js.map"]},"metadata":{},"sourceType":"module"}