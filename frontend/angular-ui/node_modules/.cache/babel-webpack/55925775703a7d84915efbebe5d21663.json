{"ast":null,"code":"import _classCallCheck from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\n\n/**\r\n * The main LitElement module, which defines the [[`LitElement`]] base class and\r\n * related APIs.\r\n *\r\n *  LitElement components can define a template and a set of observed\r\n * properties. Changing an observed property triggers a re-render of the\r\n * element.\r\n *\r\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\r\n * component:\r\n *\r\n *  ```js\r\n * import {LitElement, html} from 'lit-element';\r\n *\r\n * class MyElement extends LitElement {\r\n *\r\n *   // Declare observed properties\r\n *   static get properties() {\r\n *     return {\r\n *       adjective: {}\r\n *     }\r\n *   }\r\n *\r\n *   constructor() {\r\n *     this.adjective = 'awesome';\r\n *   }\r\n *\r\n *   // Define the element's template\r\n *   render() {\r\n *     return html`<p>your ${adjective} template here</p>`;\r\n *   }\r\n * }\r\n *\r\n * customElements.define('my-element', MyElement);\r\n * ```\r\n *\r\n * `LitElement` extends [[`UpdatingElement`]] and adds lit-html templating.\r\n * The `UpdatingElement` class is provided for users that want to build\r\n * their own custom element base classes that don't use lit-html.\r\n *\r\n * @packageDocumentation\r\n */\nimport { render } from 'lit-html/lib/shady-render.js';\nimport { UpdatingElement } from './lib/updating-element.js';\nexport * from './lib/updating-element.js';\nexport * from './lib/decorators.js';\nexport { html, svg, TemplateResult, SVGTemplateResult } from 'lit-html/lit-html.js';\nimport { supportsAdoptingStyleSheets, unsafeCSS } from './lib/css-tag.js';\nexport * from './lib/css-tag.js'; // IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n\n(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.4.0');\n/**\r\n * Sentinal value used to avoid calling lit-html's render function when\r\n * subclasses do not implement `render`\r\n */\n\nvar renderNotImplemented = {};\n/**\r\n * Base element class that manages element properties and attributes, and\r\n * renders a lit-html template.\r\n *\r\n * To define a component, subclass `LitElement` and implement a\r\n * `render` method to provide the component's template. Define properties\r\n * using the [[`properties`]] property or the [[`property`]] decorator.\r\n */\n\nexport var LitElement = /*#__PURE__*/function (_UpdatingElement) {\n  _inherits(LitElement, _UpdatingElement);\n\n  var _super = _createSuper(LitElement);\n\n  function LitElement() {\n    _classCallCheck(this, LitElement);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(LitElement, [{\n    key: \"initialize\",\n    value:\n    /**\r\n     * Performs element initialization. By default this calls\r\n     * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and\r\n     * captures any pre-set values for registered properties.\r\n     */\n    function initialize() {\n      _get(_getPrototypeOf(LitElement.prototype), \"initialize\", this).call(this);\n\n      this.constructor._getUniqueStyles();\n\n      this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n      // element's getRootNode(). While this could be done, we're choosing not to\n      // support this now since it would require different logic around de-duping.\n\n      if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n        this.adoptStyles();\n      }\n    }\n    /**\r\n     * Returns the node into which the element should render and by default\r\n     * creates and returns an open shadowRoot. Implement to customize where the\r\n     * element's DOM is rendered. For example, to render into the element's\r\n     * childNodes, return `this`.\r\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\r\n     */\n\n  }, {\n    key: \"createRenderRoot\",\n    value: function createRenderRoot() {\n      return this.attachShadow({\n        mode: 'open'\n      });\n    }\n    /**\r\n     * Applies styling to the element shadowRoot using the [[`styles`]]\r\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\r\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\r\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\r\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\r\n     * end of the `shadowRoot` to [mimic spec\r\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\r\n     */\n\n  }, {\n    key: \"adoptStyles\",\n    value: function adoptStyles() {\n      var styles = this.constructor._styles;\n\n      if (styles.length === 0) {\n        return;\n      } // There are three separate cases here based on Shadow DOM support.\n      // (1) shadowRoot polyfilled: use ShadyCSS\n      // (2) shadowRoot.adoptedStyleSheets available: use it\n      // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n      // rendering\n\n\n      if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n        window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(function (s) {\n          return s.cssText;\n        }), this.localName);\n      } else if (supportsAdoptingStyleSheets) {\n        this.renderRoot.adoptedStyleSheets = styles.map(function (s) {\n          return s instanceof CSSStyleSheet ? s : s.styleSheet;\n        });\n      } else {\n        // This must be done after rendering so the actual style insertion is done\n        // in `update`.\n        this._needsShimAdoptedStyleSheets = true;\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(LitElement.prototype), \"connectedCallback\", this).call(this); // Note, first update/render handles styleElement so we only call this if\n      // connected after first update.\n\n\n      if (this.hasUpdated && window.ShadyCSS !== undefined) {\n        window.ShadyCSS.styleElement(this);\n      }\n    }\n    /**\r\n     * Updates the element. This method reflects property values to attributes\r\n     * and calls `render` to render DOM via lit-html. Setting properties inside\r\n     * this method will *not* trigger another update.\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(changedProperties) {\n      var _this = this;\n\n      // Setting properties in `render` should not trigger an update. Since\n      // updates are allowed after super.update, it's important to call `render`\n      // before that.\n      var templateResult = this.render();\n\n      _get(_getPrototypeOf(LitElement.prototype), \"update\", this).call(this, changedProperties); // If render is not implemented by the component, don't call lit-html render\n\n\n      if (templateResult !== renderNotImplemented) {\n        this.constructor.render(templateResult, this.renderRoot, {\n          scopeName: this.localName,\n          eventContext: this\n        });\n      } // When native Shadow DOM is used but adoptedStyles are not supported,\n      // insert styling after rendering to ensure adoptedStyles have highest\n      // priority.\n\n\n      if (this._needsShimAdoptedStyleSheets) {\n        this._needsShimAdoptedStyleSheets = false;\n\n        this.constructor._styles.forEach(function (s) {\n          var style = document.createElement('style');\n          style.textContent = s.cssText;\n\n          _this.renderRoot.appendChild(style);\n        });\n      }\n    }\n    /**\r\n     * Invoked on each update to perform rendering tasks. This method may return\r\n     * any value renderable by lit-html's `NodePart` - typically a\r\n     * `TemplateResult`. Setting properties inside this method will *not* trigger\r\n     * the element to update.\r\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      return renderNotImplemented;\n    }\n  }], [{\n    key: \"getStyles\",\n    value:\n    /**\r\n     * Return the array of styles to apply to the element.\r\n     * Override this method to integrate into a style management system.\r\n     *\r\n     * @nocollapse\r\n     */\n    function getStyles() {\n      return this.styles;\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"_getUniqueStyles\",\n    value: function _getUniqueStyles() {\n      // Only gather styles once per class\n      if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\n        return;\n      } // Take care not to call `this.getStyles()` multiple times since this\n      // generates new CSSResults each time.\n      // TODO(sorvell): Since we do not cache CSSResults by input, any\n      // shared styles will generate new stylesheet objects, which is wasteful.\n      // This should be addressed when a browser ships constructable\n      // stylesheets.\n\n\n      var userStyles = this.getStyles();\n\n      if (Array.isArray(userStyles)) {\n        // De-duplicate styles preserving the _last_ instance in the set.\n        // This is a performance optimization to avoid duplicated styles that can\n        // occur especially when composing via subclassing.\n        // The last item is kept to try to preserve the cascade order with the\n        // assumption that it's most important that last added styles override\n        // previous styles.\n        var addStyles = function addStyles(styles, set) {\n          return styles.reduceRight(function (set, s) {\n            return (// Note: On IE set.add() does not return the set\n              Array.isArray(s) ? addStyles(s, set) : (set.add(s), set)\n            );\n          }, set);\n        }; // Array.from does not work on Set in IE, otherwise return\n        // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n\n\n        var set = addStyles(userStyles, new Set());\n        var styles = [];\n        set.forEach(function (v) {\n          return styles.unshift(v);\n        });\n        this._styles = styles;\n      } else {\n        this._styles = userStyles === undefined ? [] : [userStyles];\n      } // Ensure that there are no invalid CSSStyleSheet instances here. They are\n      // invalid in two conditions.\n      // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but\n      //     this is impossible to check except via .replaceSync or use\n      // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is\n      //     false)\n\n\n      this._styles = this._styles.map(function (s) {\n        if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {\n          // Flatten the cssText from the passed constructible stylesheet (or\n          // undetectable non-constructible stylesheet). The user might have\n          // expected to update their stylesheets over time, but the alternative\n          // is a crash.\n          var cssText = Array.prototype.slice.call(s.cssRules).reduce(function (css, rule) {\n            return css + rule.cssText;\n          }, '');\n          return unsafeCSS(cssText);\n        }\n\n        return s;\n      });\n    }\n  }]);\n\n  return LitElement;\n}(UpdatingElement);\n/**\r\n * Ensure this class is marked as `finalized` as an optimization ensuring\r\n * it will not needlessly try to `finalize`.\r\n *\r\n * Note this property name is a string to prevent breaking Closure JS Compiler\r\n * optimizations. See updating-element.ts for more information.\r\n */\n\nLitElement['finalized'] = true;\n/**\r\n * Reference to the underlying library method used to render the element's\r\n * DOM. By default, points to the `render` method from lit-html's shady-render\r\n * module.\r\n *\r\n * **Most users will never need to touch this property.**\r\n *\r\n * This  property should not be confused with the `render` instance method,\r\n * which should be overridden to define a template for the element.\r\n *\r\n * Advanced users creating a new base class based on LitElement can override\r\n * this property to point to a custom render method with a signature that\r\n * matches [shady-render's `render`\r\n * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).\r\n *\r\n * @nocollapse\r\n */\n\nLitElement.render = render; //# sourceMappingURL=lit-element.js.map","map":{"version":3,"sources":["C:/Users/hp/OneDrive/Desktop/17portalnew/CNS-Portal/frontend/angular-ui/node_modules/lit-element/lit-element.js"],"names":["render","UpdatingElement","html","svg","TemplateResult","SVGTemplateResult","supportsAdoptingStyleSheets","unsafeCSS","window","push","renderNotImplemented","LitElement","constructor","_getUniqueStyles","renderRoot","createRenderRoot","ShadowRoot","adoptStyles","attachShadow","mode","styles","_styles","length","ShadyCSS","undefined","nativeShadow","ScopingShim","prepareAdoptedCssText","map","s","cssText","localName","adoptedStyleSheets","CSSStyleSheet","styleSheet","_needsShimAdoptedStyleSheets","hasUpdated","styleElement","changedProperties","templateResult","scopeName","eventContext","forEach","style","document","createElement","textContent","appendChild","hasOwnProperty","JSCompiler_renameProperty","userStyles","getStyles","Array","isArray","addStyles","set","reduceRight","add","Set","v","unshift","prototype","slice","call","cssRules","reduce","css","rule"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,8BAAvB;AACA,SAASC,eAAT,QAAgC,2BAAhC;AACA,cAAc,2BAAd;AACA,cAAc,qBAAd;AACA,SAASC,IAAT,EAAeC,GAAf,EAAoBC,cAApB,EAAoCC,iBAApC,QAA6D,sBAA7D;AACA,SAASC,2BAAT,EAAsCC,SAAtC,QAAuD,kBAAvD;AACA,cAAc,kBAAd,C,CACA;AACA;AACA;;AACA,CAACC,MAAM,CAAC,oBAAD,CAAN,KAAiCA,MAAM,CAAC,oBAAD,CAAN,GAA+B,EAAhE,CAAD,EACKC,IADL,CACU,OADV;AAEA;AACA;AACA;AACA;;AACA,IAAMC,oBAAoB,GAAG,EAA7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,UAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AA8DI;AACJ;AACA;AACA;AACA;AACI,0BAAa;AACT;;AACA,WAAKC,WAAL,CAAiBC,gBAAjB;;AACA,WAAKC,UAAL,GAAkB,KAAKC,gBAAL,EAAlB,CAHS,CAIT;AACA;AACA;;AACA,UAAIP,MAAM,CAACQ,UAAP,IAAqB,KAAKF,UAAL,YAA2BN,MAAM,CAACQ,UAA3D,EAAuE;AACnE,aAAKC,WAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AApFA;AAAA;AAAA,WAqFI,4BAAmB;AACf,aAAO,KAAKC,YAAL,CAAkB;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAAlB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhGA;AAAA;A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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\n/**\r\n * The main LitElement module, which defines the [[`LitElement`]] base class and\r\n * related APIs.\r\n *\r\n *  LitElement components can define a template and a set of observed\r\n * properties. Changing an observed property triggers a re-render of the\r\n * element.\r\n *\r\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\r\n * component:\r\n *\r\n *  ```js\r\n * import {LitElement, html} from 'lit-element';\r\n *\r\n * class MyElement extends LitElement {\r\n *\r\n *   // Declare observed properties\r\n *   static get properties() {\r\n *     return {\r\n *       adjective: {}\r\n *     }\r\n *   }\r\n *\r\n *   constructor() {\r\n *     this.adjective = 'awesome';\r\n *   }\r\n *\r\n *   // Define the element's template\r\n *   render() {\r\n *     return html`<p>your ${adjective} template here</p>`;\r\n *   }\r\n * }\r\n *\r\n * customElements.define('my-element', MyElement);\r\n * ```\r\n *\r\n * `LitElement` extends [[`UpdatingElement`]] and adds lit-html templating.\r\n * The `UpdatingElement` class is provided for users that want to build\r\n * their own custom element base classes that don't use lit-html.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { render } from 'lit-html/lib/shady-render.js';\r\nimport { UpdatingElement } from './lib/updating-element.js';\r\nexport * from './lib/updating-element.js';\r\nexport * from './lib/decorators.js';\r\nexport { html, svg, TemplateResult, SVGTemplateResult } from 'lit-html/lit-html.js';\r\nimport { supportsAdoptingStyleSheets, unsafeCSS } from './lib/css-tag.js';\r\nexport * from './lib/css-tag.js';\r\n// IMPORTANT: do not change the property name or the assignment expression.\r\n// This line will be used in regexes to search for LitElement usage.\r\n// TODO(justinfagnani): inject version number at build time\r\n(window['litElementVersions'] || (window['litElementVersions'] = []))\r\n    .push('2.4.0');\r\n/**\r\n * Sentinal value used to avoid calling lit-html's render function when\r\n * subclasses do not implement `render`\r\n */\r\nconst renderNotImplemented = {};\r\n/**\r\n * Base element class that manages element properties and attributes, and\r\n * renders a lit-html template.\r\n *\r\n * To define a component, subclass `LitElement` and implement a\r\n * `render` method to provide the component's template. Define properties\r\n * using the [[`properties`]] property or the [[`property`]] decorator.\r\n */\r\nexport class LitElement extends UpdatingElement {\r\n    /**\r\n     * Return the array of styles to apply to the element.\r\n     * Override this method to integrate into a style management system.\r\n     *\r\n     * @nocollapse\r\n     */\r\n    static getStyles() {\r\n        return this.styles;\r\n    }\r\n    /** @nocollapse */\r\n    static _getUniqueStyles() {\r\n        // Only gather styles once per class\r\n        if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\r\n            return;\r\n        }\r\n        // Take care not to call `this.getStyles()` multiple times since this\r\n        // generates new CSSResults each time.\r\n        // TODO(sorvell): Since we do not cache CSSResults by input, any\r\n        // shared styles will generate new stylesheet objects, which is wasteful.\r\n        // This should be addressed when a browser ships constructable\r\n        // stylesheets.\r\n        const userStyles = this.getStyles();\r\n        if (Array.isArray(userStyles)) {\r\n            // De-duplicate styles preserving the _last_ instance in the set.\r\n            // This is a performance optimization to avoid duplicated styles that can\r\n            // occur especially when composing via subclassing.\r\n            // The last item is kept to try to preserve the cascade order with the\r\n            // assumption that it's most important that last added styles override\r\n            // previous styles.\r\n            const addStyles = (styles, set) => styles.reduceRight((set, s) => \r\n            // Note: On IE set.add() does not return the set\r\n            Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);\r\n            // Array.from does not work on Set in IE, otherwise return\r\n            // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\r\n            const set = addStyles(userStyles, new Set());\r\n            const styles = [];\r\n            set.forEach((v) => styles.unshift(v));\r\n            this._styles = styles;\r\n        }\r\n        else {\r\n            this._styles = userStyles === undefined ? [] : [userStyles];\r\n        }\r\n        // Ensure that there are no invalid CSSStyleSheet instances here. They are\r\n        // invalid in two conditions.\r\n        // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but\r\n        //     this is impossible to check except via .replaceSync or use\r\n        // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is\r\n        //     false)\r\n        this._styles = this._styles.map((s) => {\r\n            if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {\r\n                // Flatten the cssText from the passed constructible stylesheet (or\r\n                // undetectable non-constructible stylesheet). The user might have\r\n                // expected to update their stylesheets over time, but the alternative\r\n                // is a crash.\r\n                const cssText = Array.prototype.slice.call(s.cssRules)\r\n                    .reduce((css, rule) => css + rule.cssText, '');\r\n                return unsafeCSS(cssText);\r\n            }\r\n            return s;\r\n        });\r\n    }\r\n    /**\r\n     * Performs element initialization. By default this calls\r\n     * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and\r\n     * captures any pre-set values for registered properties.\r\n     */\r\n    initialize() {\r\n        super.initialize();\r\n        this.constructor._getUniqueStyles();\r\n        this.renderRoot = this.createRenderRoot();\r\n        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\r\n        // element's getRootNode(). While this could be done, we're choosing not to\r\n        // support this now since it would require different logic around de-duping.\r\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\r\n            this.adoptStyles();\r\n        }\r\n    }\r\n    /**\r\n     * Returns the node into which the element should render and by default\r\n     * creates and returns an open shadowRoot. Implement to customize where the\r\n     * element's DOM is rendered. For example, to render into the element's\r\n     * childNodes, return `this`.\r\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\r\n     */\r\n    createRenderRoot() {\r\n        return this.attachShadow({ mode: 'open' });\r\n    }\r\n    /**\r\n     * Applies styling to the element shadowRoot using the [[`styles`]]\r\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\r\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\r\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\r\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\r\n     * end of the `shadowRoot` to [mimic spec\r\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\r\n     */\r\n    adoptStyles() {\r\n        const styles = this.constructor._styles;\r\n        if (styles.length === 0) {\r\n            return;\r\n        }\r\n        // There are three separate cases here based on Shadow DOM support.\r\n        // (1) shadowRoot polyfilled: use ShadyCSS\r\n        // (2) shadowRoot.adoptedStyleSheets available: use it\r\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\r\n        // rendering\r\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\r\n            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);\r\n        }\r\n        else if (supportsAdoptingStyleSheets) {\r\n            this.renderRoot.adoptedStyleSheets =\r\n                styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);\r\n        }\r\n        else {\r\n            // This must be done after rendering so the actual style insertion is done\r\n            // in `update`.\r\n            this._needsShimAdoptedStyleSheets = true;\r\n        }\r\n    }\r\n    connectedCallback() {\r\n        super.connectedCallback();\r\n        // Note, first update/render handles styleElement so we only call this if\r\n        // connected after first update.\r\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\r\n            window.ShadyCSS.styleElement(this);\r\n        }\r\n    }\r\n    /**\r\n     * Updates the element. This method reflects property values to attributes\r\n     * and calls `render` to render DOM via lit-html. Setting properties inside\r\n     * this method will *not* trigger another update.\r\n     * @param _changedProperties Map of changed properties with old values\r\n     */\r\n    update(changedProperties) {\r\n        // Setting properties in `render` should not trigger an update. Since\r\n        // updates are allowed after super.update, it's important to call `render`\r\n        // before that.\r\n        const templateResult = this.render();\r\n        super.update(changedProperties);\r\n        // If render is not implemented by the component, don't call lit-html render\r\n        if (templateResult !== renderNotImplemented) {\r\n            this.constructor\r\n                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });\r\n        }\r\n        // When native Shadow DOM is used but adoptedStyles are not supported,\r\n        // insert styling after rendering to ensure adoptedStyles have highest\r\n        // priority.\r\n        if (this._needsShimAdoptedStyleSheets) {\r\n            this._needsShimAdoptedStyleSheets = false;\r\n            this.constructor._styles.forEach((s) => {\r\n                const style = document.createElement('style');\r\n                style.textContent = s.cssText;\r\n                this.renderRoot.appendChild(style);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Invoked on each update to perform rendering tasks. This method may return\r\n     * any value renderable by lit-html's `NodePart` - typically a\r\n     * `TemplateResult`. Setting properties inside this method will *not* trigger\r\n     * the element to update.\r\n     */\r\n    render() {\r\n        return renderNotImplemented;\r\n    }\r\n}\r\n/**\r\n * Ensure this class is marked as `finalized` as an optimization ensuring\r\n * it will not needlessly try to `finalize`.\r\n *\r\n * Note this property name is a string to prevent breaking Closure JS Compiler\r\n * optimizations. See updating-element.ts for more information.\r\n */\r\nLitElement['finalized'] = true;\r\n/**\r\n * Reference to the underlying library method used to render the element's\r\n * DOM. By default, points to the `render` method from lit-html's shady-render\r\n * module.\r\n *\r\n * **Most users will never need to touch this property.**\r\n *\r\n * This  property should not be confused with the `render` instance method,\r\n * which should be overridden to define a template for the element.\r\n *\r\n * Advanced users creating a new base class based on LitElement can override\r\n * this property to point to a custom render method with a signature that\r\n * matches [shady-render's `render`\r\n * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).\r\n *\r\n * @nocollapse\r\n */\r\nLitElement.render = render;\r\n//# sourceMappingURL=lit-element.js.map"]},"metadata":{},"sourceType":"module"}