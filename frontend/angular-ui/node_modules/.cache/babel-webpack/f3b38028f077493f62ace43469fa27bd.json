{"ast":null,"code":"import _get from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\nimport { reparentNodes } from './dom.js';\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template.js';\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\n\nvar policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {\n  createHTML: function createHTML(s) {\n    return s;\n  }\n});\nvar commentMarker = \" \".concat(marker, \" \");\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\n\nexport var TemplateResult = /*#__PURE__*/function () {\n  function TemplateResult(strings, values, type, processor) {\n    _classCallCheck(this, TemplateResult);\n\n    this.strings = strings;\n    this.values = values;\n    this.type = type;\n    this.processor = processor;\n  }\n  /**\n   * Returns a string of HTML used to create a `<template>` element.\n   */\n\n\n  _createClass(TemplateResult, [{\n    key: \"getHTML\",\n    value: function getHTML() {\n      var l = this.strings.length - 1;\n      var html = '';\n      var isCommentBinding = false;\n\n      for (var i = 0; i < l; i++) {\n        var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert\n        // into the template source before it's parsed by the browser's HTML\n        // parser. The marker type is based on whether the expression is in an\n        // attribute, text, or comment position.\n        //   * For node-position bindings we insert a comment with the marker\n        //     sentinel as its text content, like <!--{{lit-guid}}-->.\n        //   * For attribute bindings we insert just the marker sentinel for the\n        //     first binding, so that we support unquoted attribute bindings.\n        //     Subsequent bindings can use a comment marker because multi-binding\n        //     attributes must be quoted.\n        //   * For comment bindings we insert just the marker sentinel so we don't\n        //     close the comment.\n        //\n        // The following code scans the template source, but is *not* an HTML\n        // parser. We don't need to track the tree structure of the HTML, only\n        // whether a binding is inside a comment, and if not, if it appears to be\n        // the first binding in an attribute.\n\n        var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following\n        // comment close. Because <-- can appear in an attribute value there can\n        // be false positives.\n\n        isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the\n        // expression. This can match \"name=value\" like structures in text,\n        // comments, and attribute values, so there can be false-positives.\n\n        var attributeMatch = lastAttributeNameRegex.exec(s);\n\n        if (attributeMatch === null) {\n          // We're only in this branch if we don't have a attribute-like\n          // preceding sequence. For comments, this guards against unusual\n          // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n          // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n          // below.\n          html += s + (isCommentBinding ? commentMarker : nodeMarker);\n        } else {\n          // For attributes we use just a marker sentinel, and also append a\n          // $lit$ suffix to the name to opt-out of attribute-specific parsing\n          // that IE and Edge do for style and certain SVG attributes.\n          html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;\n        }\n      }\n\n      html += this.strings[l];\n      return html;\n    }\n  }, {\n    key: \"getTemplateElement\",\n    value: function getTemplateElement() {\n      var template = document.createElement('template');\n      var value = this.getHTML();\n\n      if (policy !== undefined) {\n        // this is secure because `this.strings` is a TemplateStringsArray.\n        // TODO: validate this when\n        // https://github.com/tc39/proposal-array-is-template-object is\n        // implemented.\n        value = policy.createHTML(value);\n      }\n\n      template.innerHTML = value;\n      return template;\n    }\n  }]);\n\n  return TemplateResult;\n}();\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\n\nexport var SVGTemplateResult = /*#__PURE__*/function (_TemplateResult) {\n  _inherits(SVGTemplateResult, _TemplateResult);\n\n  var _super = _createSuper(SVGTemplateResult);\n\n  function SVGTemplateResult() {\n    _classCallCheck(this, SVGTemplateResult);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SVGTemplateResult, [{\n    key: \"getHTML\",\n    value: function getHTML() {\n      return \"<svg>\".concat(_get(_getPrototypeOf(SVGTemplateResult.prototype), \"getHTML\", this).call(this), \"</svg>\");\n    }\n  }, {\n    key: \"getTemplateElement\",\n    value: function getTemplateElement() {\n      var template = _get(_getPrototypeOf(SVGTemplateResult.prototype), \"getTemplateElement\", this).call(this);\n\n      var content = template.content;\n      var svgElement = content.firstChild;\n      content.removeChild(svgElement);\n      reparentNodes(content, svgElement.firstChild);\n      return template;\n    }\n  }]);\n\n  return SVGTemplateResult;\n}(TemplateResult); //# sourceMappingURL=template-result.js.map","map":{"version":3,"sources":["C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/lit-html/lib/template-result.js"],"names":["reparentNodes","boundAttributeSuffix","lastAttributeNameRegex","marker","nodeMarker","policy","window","trustedTypes","createPolicy","createHTML","s","commentMarker","TemplateResult","strings","values","type","processor","l","length","html","isCommentBinding","i","commentOpen","lastIndexOf","indexOf","attributeMatch","exec","substr","index","template","document","createElement","value","getHTML","undefined","innerHTML","SVGTemplateResult","content","svgElement","firstChild","removeChild"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { reparentNodes } from './dom.js';\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template.js';\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = window.trustedTypes &&\n    trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it's parsed by the browser's HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment position.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like <!--{{lit-guid}}-->.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don't\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don't need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf('<!--');\n            // We're in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf('-->', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceding the\n            // expression. This can match \"name=value\" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We're only in this branch if we don't have a attribute-like\n                // preceding sequence. For comments, this guards against unusual\n                // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        let value = this.getHTML();\n        if (policy !== undefined) {\n            // this is secure because `this.strings` is a TemplateStringsArray.\n            // TODO: validate this when\n            // https://github.com/tc39/proposal-array-is-template-object is\n            // implemented.\n            value = policy.createHTML(value);\n        }\n        template.innerHTML = value;\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map"]},"metadata":{},"sourceType":"module"}