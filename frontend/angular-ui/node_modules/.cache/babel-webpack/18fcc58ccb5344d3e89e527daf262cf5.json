{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\nimport { isTemplatePartActive } from './template.js';\nvar walkerNodeFilter = 133\n/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n;\n/**\r\n * Removes the list of nodes from a Template safely. In addition to removing\r\n * nodes from the Template, the Template part indices are updated to match\r\n * the mutated Template DOM.\r\n *\r\n * As the template is walked the removal state is tracked and\r\n * part indices are adjusted as needed.\r\n *\r\n * div\r\n *   div#1 (remove) <-- start removing (removing node is div#1)\r\n *     div\r\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\r\n *         div\r\n * div <-- stop removing since previous sibling is the removing node (div#1,\r\n * removed 4 nodes)\r\n */\n\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n  var content = template.element.content,\n      parts = template.parts;\n  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  var partIndex = nextActiveIndexInTemplateParts(parts);\n  var part = parts[partIndex];\n  var nodeIndex = -1;\n  var removeCount = 0;\n  var nodesToRemoveInTemplate = [];\n  var currentRemovingNode = null;\n\n  while (walker.nextNode()) {\n    nodeIndex++;\n    var node = walker.currentNode; // End removal if stepped past the removing node\n\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    } // A node to remove was found in the template\n\n\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node); // Track node we're removing\n\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    } // When removing, increment count by which to adjust subsequent part indices\n\n\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n\n  nodesToRemoveInTemplate.forEach(function (n) {\n    return n.parentNode.removeChild(n);\n  });\n}\n\nvar countNodes = function countNodes(node) {\n  var count = node.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  ? 0 : 1;\n  var walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n\n  while (walker.nextNode()) {\n    count++;\n  }\n\n  return count;\n};\n\nvar nextActiveIndexInTemplateParts = function nextActiveIndexInTemplateParts(parts) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n  for (var i = startIndex + 1; i < parts.length; i++) {\n    var part = parts[i];\n\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\r\n * Inserts the given node into the Template, optionally before the given\r\n * refNode. In addition to inserting the node into the Template, the Template\r\n * part indices are updated to match the mutated Template DOM.\r\n */\n\n\nexport function insertNodeIntoTemplate(template, node) {\n  var refNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var content = template.element.content,\n      parts = template.parts; // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n\n  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  var partIndex = nextActiveIndexInTemplateParts(parts);\n  var insertCount = 0;\n  var walkerIndex = -1;\n\n  while (walker.nextNode()) {\n    walkerIndex++;\n    var walkerNode = walker.currentNode;\n\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode.insertBefore(node, refNode);\n    }\n\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n\n        return;\n      }\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n} //# sourceMappingURL=modify-template.js.map","map":{"version":3,"sources":["C:/Users/hp/OneDrive/Desktop/19portal/CNS-Portal/frontend/angular-ui/node_modules/lit-html/lib/modify-template.js"],"names":["isTemplatePartActive","walkerNodeFilter","removeNodesFromTemplate","template","nodesToRemove","content","element","parts","walker","document","createTreeWalker","partIndex","nextActiveIndexInTemplateParts","part","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","nextNode","node","currentNode","previousSibling","has","push","undefined","index","forEach","n","parentNode","removeChild","countNodes","count","nodeType","startIndex","i","length","insertNodeIntoTemplate","refNode","appendChild","insertCount","walkerIndex","walkerNode","insertBefore"],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at\r\n * http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at\r\n * http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at\r\n * http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at\r\n * http://polymer.github.io/PATENTS.txt\r\n */\r\nimport { isTemplatePartActive } from './template.js';\r\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\r\n/**\r\n * Removes the list of nodes from a Template safely. In addition to removing\r\n * nodes from the Template, the Template part indices are updated to match\r\n * the mutated Template DOM.\r\n *\r\n * As the template is walked the removal state is tracked and\r\n * part indices are adjusted as needed.\r\n *\r\n * div\r\n *   div#1 (remove) <-- start removing (removing node is div#1)\r\n *     div\r\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\r\n *         div\r\n * div <-- stop removing since previous sibling is the removing node (div#1,\r\n * removed 4 nodes)\r\n */\r\nexport function removeNodesFromTemplate(template, nodesToRemove) {\r\n    const { element: { content }, parts } = template;\r\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\r\n    let partIndex = nextActiveIndexInTemplateParts(parts);\r\n    let part = parts[partIndex];\r\n    let nodeIndex = -1;\r\n    let removeCount = 0;\r\n    const nodesToRemoveInTemplate = [];\r\n    let currentRemovingNode = null;\r\n    while (walker.nextNode()) {\r\n        nodeIndex++;\r\n        const node = walker.currentNode;\r\n        // End removal if stepped past the removing node\r\n        if (node.previousSibling === currentRemovingNode) {\r\n            currentRemovingNode = null;\r\n        }\r\n        // A node to remove was found in the template\r\n        if (nodesToRemove.has(node)) {\r\n            nodesToRemoveInTemplate.push(node);\r\n            // Track node we're removing\r\n            if (currentRemovingNode === null) {\r\n                currentRemovingNode = node;\r\n            }\r\n        }\r\n        // When removing, increment count by which to adjust subsequent part indices\r\n        if (currentRemovingNode !== null) {\r\n            removeCount++;\r\n        }\r\n        while (part !== undefined && part.index === nodeIndex) {\r\n            // If part is in a removed node deactivate it by setting index to -1 or\r\n            // adjust the index as needed.\r\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\r\n            // go to the next active part.\r\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\r\n            part = parts[partIndex];\r\n        }\r\n    }\r\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\r\n}\r\nconst countNodes = (node) => {\r\n    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\r\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\r\n    while (walker.nextNode()) {\r\n        count++;\r\n    }\r\n    return count;\r\n};\r\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\r\n    for (let i = startIndex + 1; i < parts.length; i++) {\r\n        const part = parts[i];\r\n        if (isTemplatePartActive(part)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n/**\r\n * Inserts the given node into the Template, optionally before the given\r\n * refNode. In addition to inserting the node into the Template, the Template\r\n * part indices are updated to match the mutated Template DOM.\r\n */\r\nexport function insertNodeIntoTemplate(template, node, refNode = null) {\r\n    const { element: { content }, parts } = template;\r\n    // If there's no refNode, then put node at end of template.\r\n    // No part indices need to be shifted in this case.\r\n    if (refNode === null || refNode === undefined) {\r\n        content.appendChild(node);\r\n        return;\r\n    }\r\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\r\n    let partIndex = nextActiveIndexInTemplateParts(parts);\r\n    let insertCount = 0;\r\n    let walkerIndex = -1;\r\n    while (walker.nextNode()) {\r\n        walkerIndex++;\r\n        const walkerNode = walker.currentNode;\r\n        if (walkerNode === refNode) {\r\n            insertCount = countNodes(node);\r\n            refNode.parentNode.insertBefore(node, refNode);\r\n        }\r\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\r\n            // If we've inserted the node, simply adjust all subsequent parts\r\n            if (insertCount > 0) {\r\n                while (partIndex !== -1) {\r\n                    parts[partIndex].index += insertCount;\r\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\r\n                }\r\n                return;\r\n            }\r\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=modify-template.js.map"]},"metadata":{},"sourceType":"module"}