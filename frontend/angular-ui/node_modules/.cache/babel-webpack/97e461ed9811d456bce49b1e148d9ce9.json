{"ast":null,"code":"import _classCallCheck from \"C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport var marker = \"{{lit-\".concat(String(Math.random()).slice(2), \"}}\");\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\n\nexport var nodeMarker = \"<!--\".concat(marker, \"-->\");\nexport var markerRegex = new RegExp(\"\".concat(marker, \"|\").concat(nodeMarker));\n/**\n * Suffix appended to all bound attribute names.\n */\n\nexport var boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\n\nexport var Template = function Template(result, element) {\n  _classCallCheck(this, Template);\n\n  this.parts = [];\n  this.element = element;\n  var nodesToRemove = [];\n  var stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\n  var walker = document.createTreeWalker(element.content, 133\n  /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n  , null, false); // Keeps track of the last index associated with a part. We try to delete\n  // unnecessary nodes, but we never want to associate two different parts\n  // to the same index. They must have a constant node between.\n\n  var lastPartIndex = 0;\n  var index = -1;\n  var partIndex = 0;\n  var strings = result.strings,\n      length = result.values.length;\n\n  while (partIndex < length) {\n    var node = walker.nextNode();\n\n    if (node === null) {\n      // We've exhausted the content inside a nested template element.\n      // Because we still have parts (the outer for-loop), we know:\n      // - There is a template in the stack\n      // - The walker will find a nextNode outside the template\n      walker.currentNode = stack.pop();\n      continue;\n    }\n\n    index++;\n\n    if (node.nodeType === 1\n    /* Node.ELEMENT_NODE */\n    ) {\n        if (node.hasAttributes()) {\n          var attributes = node.attributes;\n          var _length = attributes.length; // Per\n          // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n          // attributes are not guaranteed to be returned in document order.\n          // In particular, Edge/IE can return them out of order, so we cannot\n          // assume a correspondence between part index and attribute index.\n\n          var count = 0;\n\n          for (var i = 0; i < _length; i++) {\n            if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n              count++;\n            }\n          }\n\n          while (count-- > 0) {\n            // Get the template literal section leading up to the first\n            // expression in this attribute\n            var stringForPart = strings[partIndex]; // Find the attribute name\n\n            var name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute\n            // All bound attributes have had a suffix added in\n            // TemplateResult#getHTML to opt out of special attribute\n            // handling. To look up the attribute value we also need to add\n            // the suffix.\n\n            var attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n            var attributeValue = node.getAttribute(attributeLookupName);\n            node.removeAttribute(attributeLookupName);\n            var statics = attributeValue.split(markerRegex);\n            this.parts.push({\n              type: 'attribute',\n              index: index,\n              name: name,\n              strings: statics\n            });\n            partIndex += statics.length - 1;\n          }\n        }\n\n        if (node.tagName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n      } else if (node.nodeType === 3\n    /* Node.TEXT_NODE */\n    ) {\n        var data = node.data;\n\n        if (data.indexOf(marker) >= 0) {\n          var parent = node.parentNode;\n\n          var _strings = data.split(markerRegex);\n\n          var lastIndex = _strings.length - 1; // Generate a new text node for each literal section\n          // These nodes are also used as the markers for node parts\n\n          for (var _i = 0; _i < lastIndex; _i++) {\n            var insert = void 0;\n            var s = _strings[_i];\n\n            if (s === '') {\n              insert = createMarker();\n            } else {\n              var match = lastAttributeNameRegex.exec(s);\n\n              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n              }\n\n              insert = document.createTextNode(s);\n            }\n\n            parent.insertBefore(insert, node);\n            this.parts.push({\n              type: 'node',\n              index: ++index\n            });\n          } // If there's no text, we must insert a comment to mark our place.\n          // Else, we can trust it will stick around after cloning.\n\n\n          if (_strings[lastIndex] === '') {\n            parent.insertBefore(createMarker(), node);\n            nodesToRemove.push(node);\n          } else {\n            node.data = _strings[lastIndex];\n          } // We have a part for each match found\n\n\n          partIndex += lastIndex;\n        }\n      } else if (node.nodeType === 8\n    /* Node.COMMENT_NODE */\n    ) {\n        if (node.data === marker) {\n          var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of\n          // the following are true:\n          //  * We don't have a previousSibling\n          //  * The previousSibling is already the start of a previous part\n\n          if (node.previousSibling === null || index === lastPartIndex) {\n            index++;\n\n            _parent.insertBefore(createMarker(), node);\n          }\n\n          lastPartIndex = index;\n          this.parts.push({\n            type: 'node',\n            index: index\n          }); // If we don't have a nextSibling, keep this node so we have an end.\n          // Else, we can remove it to save future costs.\n\n          if (node.nextSibling === null) {\n            node.data = '';\n          } else {\n            nodesToRemove.push(node);\n            index--;\n          }\n\n          partIndex++;\n        } else {\n          var _i2 = -1;\n\n          while ((_i2 = node.data.indexOf(marker, _i2 + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            this.parts.push({\n              type: 'node',\n              index: -1\n            });\n            partIndex++;\n          }\n        }\n      }\n  } // Remove text binding nodes after the walk to not disturb the TreeWalker\n\n\n  for (var _i3 = 0, _nodesToRemove = nodesToRemove; _i3 < _nodesToRemove.length; _i3++) {\n    var n = _nodesToRemove[_i3];\n    n.parentNode.removeChild(n);\n  }\n};\n\nvar endsWith = function endsWith(str, suffix) {\n  var index = str.length - suffix.length;\n  return index >= 0 && str.slice(index) === suffix;\n};\n\nexport var isTemplatePartActive = function isTemplatePartActive(part) {\n  return part.index !== -1;\n}; // Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\n\nexport var createMarker = function createMarker() {\n  return document.createComment('');\n};\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\n\nexport var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/; //# sourceMappingURL=template.js.map","map":{"version":3,"sources":["C:/Users/HP/Desktop/new cns-portal/CNS-Portal/frontend/angular-ui/node_modules/lit-html/lib/template.js"],"names":["marker","String","Math","random","slice","nodeMarker","markerRegex","RegExp","boundAttributeSuffix","Template","result","element","parts","nodesToRemove","stack","walker","document","createTreeWalker","content","lastPartIndex","index","partIndex","strings","length","values","node","nextNode","currentNode","pop","nodeType","hasAttributes","attributes","count","i","endsWith","name","stringForPart","lastAttributeNameRegex","exec","attributeLookupName","toLowerCase","attributeValue","getAttribute","removeAttribute","statics","split","push","type","tagName","data","indexOf","parent","parentNode","lastIndex","insert","s","createMarker","match","createTextNode","insertBefore","previousSibling","nextSibling","n","removeChild","str","suffix","isTemplatePartActive","part","createComment"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = \n// eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map"]},"metadata":{},"sourceType":"module"}